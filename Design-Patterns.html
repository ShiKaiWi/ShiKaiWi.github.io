<!DOCTYPE html>
<html>
    <head>
        <title>Design-Patterns</title>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="created" content="2018-02-22T21:58:47+0800"/>
        <meta name="modified" content="2018-02-22T22:06:00+0800"/>
        <meta name="tags" content=""/>
        <meta name="last device" content="xwei's MBP"/>
    </head>
    <body>
        <div class="note-wrapper">
            <h1>Design-Patterns</h1>
<hr>
<p>title: Design-Rules</p>
<p>date: 2017-06-15 23:55:37</p>
<hr>
<p>我本来还是相当推崇设计模式的，但是在公司里一些前辈的建议下，让我淡化设计模式本身，记住软件设计的原则，通过多看多写，来自我领悟软件工程的精髓所在，以避免生搬硬套，而走向歧途。</p>
<br>
<h1>Design Rules</h1>
<h2>0.隔离变化代码(Encapsulate varying code)</h2>
<p>应该说这是设计模式的核心思想，所有的设计模式都是按照这个规则来提出的，因此这个规则也没有什么可以说的，只需要牢记在心。</p>
<br>
<h2>1.面向接口优于面向实现(Programming to Interface rather Implements)</h2>
<p>这是很重要的一点，在举例子之前首先需要知道这里 Interface 和 Implement 的意思，尤其是对 Java 的使用者来说，很容易产生混乱。</p>
<br>
<p>这里 Interface 更好的表述其实应该是 Supertype，所谓面向 Interface，其实应该说是面向 Supertype，而作为 Supertype，我们需要知道的是使用 Supertype 再配合 Polymorphism，就可以使得代码的变化变少，因为 Supertype 类型的 variable 有着更强的代码兼容性（越抽象适用性更广泛）。</p>
<br>
<p>而所谓的 Implement 其实是相对于 Supertype 来说的，面向 Implement 编程实际上就是在编程中经常使用具体的类或类型来定义变量，从而导致代码发生变化的时候，改动会非常多。</p>
<br>
<p>下面举一个例子会更方便理解。</p>
<br>
<h3>问题描述：现在假设我们要设计一个游戏场景，场景中我们需要让一个狗发出声音，面对这个需求我们怎么实现会比较优雅？</h3>
<p>一种快速的方法其实就是面向 Implement 的实现，首先实现一个 class 叫做 Dog:</p>
<pre><code class='code-multiline'><span class="sf_code_syntax_project">class</span> <span class="sf_code_syntax_project">Dog</span> {
    <span class="sf_code_syntax_project">private</span> name;
    <span class="sf_code_syntax_project">public</span> <span class="sf_code_syntax_project">Dog</span>(name) {
        name <span class="sf_code_syntax_keyword">=</span> name;
    }
    <span class="sf_code_syntax_project">public</span> <span class="sf_code_syntax_project">String</span> getName() {
        <span class="sf_code_syntax_keyword">return</span> name;
    }
    <span class="sf_code_syntax_project">public</span> <span class="sf_code_syntax_project">void</span> bark() {
        <span class="sf_code_syntax_comment">//...
</span>    }
}</code></pre>
<p><br></p>
<p>然后在需要的地方，加上这段代码：</p>
<pre><code class='code-multiline'><span class="sf_code_syntax_project">Dog</span> dog <span class="sf_code_syntax_keyword">=</span> <span class="sf_code_syntax_keyword">new</span> <span class="sf_code_syntax_project">Dog</span>(<span class="sf_code_syntax_string">"Spot"</span>);
dog<span class="sf_code_syntax_keyword">.</span>bark()</code></pre>
<p><br></p>
<p>看上去挺不错的，然后你要知道代码工程中，最常见的就是需求改变，比如，将这只狗变为猫？在这样的时候你该怎么办？</p>
<p>你会说很简单啊，实现一个 Cat 的 class，实现 meow 方法，然后改代码：</p>
<pre><code class='code-multiline'><span class="sf_code_syntax_keyword">&lt;&lt;&lt;&lt;&lt;</span><span class="sf_code_syntax_project">HEAD</span>
<span class="sf_code_syntax_project">Cat</span> cat <span class="sf_code_syntax_keyword">=</span> <span class="sf_code_syntax_keyword">new</span> <span class="sf_code_syntax_project">Cat</span>(<span class="sf_code_syntax_string">"Mimi"</span>);
cat<span class="sf_code_syntax_keyword">.</span>meow()
<span class="sf_code_syntax_keyword">==========</span>
<span class="sf_code_syntax_project">Dog</span> dog <span class="sf_code_syntax_keyword">=</span> <span class="sf_code_syntax_keyword">new</span> <span class="sf_code_syntax_project">Dog</span>(<span class="sf_code_syntax_string">"Spot"</span>);
dog<span class="sf_code_syntax_keyword">.</span>bark()
<span class="sf_code_syntax_keyword">&gt;&gt;&gt;&gt;&gt;</span><span class="sf_code_syntax_project">Old</span></code></pre>
<p><br></p>
<p>现在看来改动也不是很多嘛，但是这里只是举一个例子，然而在实际工程中，很有可能这样的改动会牵扯到几十处，那么那样的改动就十分痛苦了。</p>
<br>
<p>现在我们看看如何使用，面向 Interface 编程来解决这个问题。</p>
<br>
<p>记住：面向 Interface == 面向 Supertype</p>
<p>因此我们首先先设计一个抽象类：</p>
<pre><code class='code-multiline'><span class="sf_code_syntax_project">Abstract</span> <span class="sf_code_syntax_project">class</span> <span class="sf_code_syntax_project">Animal</span> {
    <span class="sf_code_syntax_project">private</span> name;

    <span class="sf_code_syntax_project">public</span> <span class="sf_code_syntax_project">Animal</span>(name) {
        name <span class="sf_code_syntax_keyword">=</span> name;
    }

    <span class="sf_code_syntax_project">public</span> <span class="sf_code_syntax_project">String</span> getName() {
        <span class="sf_code_syntax_keyword">return</span> name;
    }

    <span class="sf_code_syntax_project">public</span> <span class="sf_code_syntax_project">void</span> makeSound();
}</code></pre>
<p><br></p>
<p>然后我们继承这个类，先实现 Dog 类：</p>
<pre><code class='code-multiline'><span class="sf_code_syntax_project">class</span> <span class="sf_code_syntax_project">Dog</span> <span class="sf_code_syntax_project">extends</span> <span class="sf_code_syntax_project">Animal</span> {
    @override
    <span class="sf_code_syntax_project">public</span> <span class="sf_code_syntax_project">void</span> makeSound() {
        <span class="sf_code_syntax_comment">//...
</span>    }
}</code></pre>
<p><br></p>
<p>那么调用这段代码的时候，我们要这么写:</p>
<pre><code class='code-multiline'><span class="sf_code_syntax_project">Animal</span> animal <span class="sf_code_syntax_keyword">=</span> <span class="sf_code_syntax_keyword">new</span> <span class="sf_code_syntax_project">Dog</span>(<span class="sf_code_syntax_string">"Spot"</span>);
animal<span class="sf_code_syntax_keyword">.</span>makeSound()</code></pre>
<p><br></p>
<p>如果再遇到要将 Dog 改成 Cat 的情况，那么我们就可以先实现 Cat 这个类（继承自 Animal），然后只需要改动一行：</p>
<pre><code class='code-multiline'><span class="sf_code_syntax_keyword">&lt;&lt;&lt;&lt;&lt;</span><span class="sf_code_syntax_project">HEAD</span>
<span class="sf_code_syntax_project">Animal</span> animal <span class="sf_code_syntax_keyword">=</span> <span class="sf_code_syntax_keyword">new</span> <span class="sf_code_syntax_project">Cat</span>(<span class="sf_code_syntax_string">"Mimi"</span>);
<span class="sf_code_syntax_keyword">=====</span>
<span class="sf_code_syntax_project">Animal</span> animal <span class="sf_code_syntax_keyword">=</span> <span class="sf_code_syntax_keyword">new</span> <span class="sf_code_syntax_project">Dog</span>(<span class="sf_code_syntax_string">"Sopt"</span>);
<span class="sf_code_syntax_keyword">&gt;&gt;&gt;&gt;&gt;</span><span class="sf_code_syntax_project">Old</span>
animal<span class="sf_code_syntax_keyword">.</span>makeSound</code></pre>
<p><br></p>
<p>这里也许有一点不好的事， animal 这个变量名太过抽象，代码的可读性不是很好，其实这里可以用具体的名字来代替，之后可以借助一些 Refactor 工具，可以瞬间改掉所有的名字，完全没有任何风险。</p>
<br>
<h2>2.组合优于继承(Favor Composition over Inheritance)</h2>
<p>组合优于继承的原因其实是很容易理解的，一旦使用了继承那么你的方法都必须被实现，被实现就意味着代码无法动态变化，无法动态变化也就意味着复用率变低。</p>
<br>
<p>而如果使用组合的话，我们便可以使用 Supertype 来持有某个类的 Instance，然后在需要变化的时候，可以将这个变量动态换成另外的 Instance 并且同时不对代码造成影响。</p>
<br>
<h2>3.低耦合(Loose Coupling)</h2>
<p>不同对象之间的耦合度越低自然会带来越好的编程体验，不过在说它的好处之前有一点需要理清的是，什么样的耦合算低？</p>
<br>
<p>我现在的看法是，两个对象之间对彼此的 Knowledge 知道的越少，耦合越低，那么什么是 Knowledge 呢？</p>
<p>具体来说有两点：</p>
<ol start="1"><li>使用对方的 public method 的次数，使用的越少，耦合度就越低。（有待商榷）
</li><li>一个类知道的其他 type 越少，耦合度就越低。
</li></ol>
<br>
<p>低耦合带来的好处是显而易见的：</p>
<ol start="1"><li>修改各自的代码实现对另一方的影响会很低，或者说只要保证暴露给对方的 method 不变，就几乎不会对对方造成任何影响
</li><li>代码复用率高，双方的使用场景将不限于彼此
</li></ol>
<br>
<p>观察者模式就是这条规则的具体体现。</p>
<br>
<h2>4.拓展类而非修改(Classes should be open for extension, but closed for modification)</h2>
<p>好处不必多说，花了大力气写好的、工作正常的、可读性好的代码，如果随便修改那是多么可惜，因此拓展类而不是修改它。</p>
<br>
<p>其实这条 rule 的关键在于怎么做到？这个问题又分为两个子问题：</p>
<br>
<ol start="1"><li>怎么在设计的时候，就避免之后的出现必要的改动？
</li></ol>
<p>这个问题我觉得自己暂时还讲不清楚，可能更多的是需要经验，然后总结出规律。</p>
<ol start="2"><li>怎么在使用拓展来代替修改？
</li></ol>
<p>这个可以借助一些设计模式，比如 Decorator。</p>
<br>
<h2>5.依赖逆转(Dependency Inversion)</h2>
<p>这是一个很重要的原则，在 Head 书中我个人觉得讲得不是很清楚。</p>
<br>
<p>在用具体的例子解释之前，名词的定义必须要理解，即什么是 Dependency？什么是 Invertion？</p>
<br>
<h3>Dependency</h3>
<p>从字面上理解，就知道肯定存在多个事物，不妨就认为是两个类，Class A & B，那么我们都知道，如果在 A 中使用 B 的同时，又在 B 中使用 A，肯定是一种一般意义上不好的用法，因此不妨认为只会在 A 中使用 B。</p>
<br>
<p>如果我们需要在 A 中使用 B，那么实际上就是 A 需要让 B 来达到某种效果，而一般认为的做法实际上就是在实现 B 的时候，实现某些功能，然后我们在 A 中会根据 B 暴露的方法去使用，然后便可以通过这一系列的调用来解决问题，这个过程中 A 是 depend on B 的，得看 B 实现了什么功能，然后去调用它实现的功能。</p>
<br>
<p>这就是 Dependency Inversion 中 Dependency 的含义。</p>
<br>
<h3>Inversion</h3>
<p>说到这里你也许就知道了，Inversion 含义就是将上面的例子中 A depend on B，转化为 B depend on A。</p>
<br>
<p>至于怎么 invert，以及为什么要 invert。我们直接通过一个例子来看。</p>
<br>
<p>试想这样一个例子，我们有两个类，PriceAverager 和 Commodity，基本的定义如下:</p>
<pre><code class='code-multiline'><span class="sf_code_syntax_project">class</span> <span class="sf_code_syntax_project">PriceAverager</span> {
    <span class="sf_code_syntax_project">private</span> <span class="sf_code_syntax_project">Commodity</span> commodity1;
    <span class="sf_code_syntax_project">private</span> <span class="sf_code_syntax_project">Commodity</span> commodity2;

    <span class="sf_code_syntax_project">public</span> <span class="sf_code_syntax_project">PriceAverager</span>(<span class="sf_code_syntax_project">Commodity</span> c1, <span class="sf_code_syntax_project">Commodity</span> c2) {
        commodity1 <span class="sf_code_syntax_keyword">=</span> c1;
        commodity2 <span class="sf_code_syntax_keyword">=</span> c2;
    }

    <span class="sf_code_syntax_project">float</span> getAveragePrice() {
        <span class="sf_code_syntax_keyword">return</span> (c1<span class="sf_code_syntax_keyword">.</span>getPrice() <span class="sf_code_syntax_keyword">+</span> c2<span class="sf_code_syntax_keyword">.</span>getPrice()) <span class="sf_code_syntax_keyword">/</span> <span class="sf_code_syntax_number">2</span>;
    }
}


<span class="sf_code_syntax_project">class</span> <span class="sf_code_syntax_project">Commodity</span> {
    <span class="sf_code_syntax_project">private</span> <span class="sf_code_syntax_project">String</span> name;
    <span class="sf_code_syntax_project">private</span> <span class="sf_code_syntax_project">float</span> price;

    constructor(<span class="sf_code_syntax_project">String</span> name, <span class="sf_code_syntax_project">float</span> price) {
        <span class="sf_code_syntax_keyword">this.</span>name <span class="sf_code_syntax_keyword">=</span> name;
        <span class="sf_code_syntax_keyword">this.</span>price <span class="sf_code_syntax_keyword">=</span> price;
    }

    <span class="sf_code_syntax_project">float</span> getPrice() {
        <span class="sf_code_syntax_keyword">return</span> price;
    }

    <span class="sf_code_syntax_project">String</span> getName() {
        <span class="sf_code_syntax_keyword">return</span> name;
    }
}
</code></pre>上面的代码很简单，就不作解释了，从代码结构看来，明显是 PriceAvereger 依赖于 Commodity 的实现，最明显的一个缺点是 PriceAverager 不能给除了 Commodity 以外的类使用（比如有一个 Food 类，并且这个类和 Commodity 没有任何关系，那么即使给 Food 类添加 getPrice 方法也没有用）。

因此我们需要 Dependency Inversion，那么怎么做？
提取一个接口：
<pre><code class='code-multiline'><span class="sf_code_syntax_project">Interface</span> <span class="sf_code_syntax_project">Priceable</span> {
    <span class="sf_code_syntax_project">float</span> getPrice();
}</code></pre>
<p><br></p>
<p>然后将之前的两个类加以修改：</p>
<pre><code class='code-multiline'><span class="sf_code_syntax_project">class</span> <span class="sf_code_syntax_project">PriceAverager</span> {
    <span class="sf_code_syntax_project">private</span> <span class="sf_code_syntax_project">Priceable</span> thing1;
    <span class="sf_code_syntax_project">private</span> <span class="sf_code_syntax_project">Priceable</span> thing2;

    <span class="sf_code_syntax_project">public</span> <span class="sf_code_syntax_project">PriceAverager</span>(<span class="sf_code_syntax_project">Priceable</span> t1, <span class="sf_code_syntax_project">Priceable</span> t2) {
        thing1 <span class="sf_code_syntax_keyword">=</span> t1;
        thing2 <span class="sf_code_syntax_keyword">=</span> t2;
    }

    <span class="sf_code_syntax_project">float</span> getAveragePrice() {
        <span class="sf_code_syntax_keyword">return</span> (t1<span class="sf_code_syntax_keyword">.</span>getPrice() <span class="sf_code_syntax_keyword">+</span> t2<span class="sf_code_syntax_keyword">.</span>getPrice()) <span class="sf_code_syntax_keyword">/</span> <span class="sf_code_syntax_number">2</span>;
    }
}


<span class="sf_code_syntax_project">class</span> <span class="sf_code_syntax_project">Commodity</span> <span class="sf_code_syntax_project">implements</span> <span class="sf_code_syntax_project">Priceable</span>{
    <span class="sf_code_syntax_project">private</span> <span class="sf_code_syntax_project">String</span> name;
    <span class="sf_code_syntax_project">private</span> <span class="sf_code_syntax_project">float</span> price;

    constructor(<span class="sf_code_syntax_project">String</span> name, <span class="sf_code_syntax_project">float</span> price) {
        <span class="sf_code_syntax_keyword">this.</span>name <span class="sf_code_syntax_keyword">=</span> name;
        <span class="sf_code_syntax_keyword">this.</span>price <span class="sf_code_syntax_keyword">=</span> price;
    }

    @override
    <span class="sf_code_syntax_project">float</span> getPrice() {
        <span class="sf_code_syntax_keyword">return</span> price;
    }

    <span class="sf_code_syntax_project">String</span> getName() {
        <span class="sf_code_syntax_keyword">return</span> name;
    }
}</code></pre>
<p><br></p>
<p>那么如果再想添加新的、可以给 PriceAverager 使用的类，只需要实现 Priceable 就行了。</p>
<br>
<p>观察第二种写法会发现在实现 Commodity 的时候，它不在是自己随便实现了，而是被限制了，它有了 dependency，它依赖于 Priceable 接口，而 Priceable 接口实际上是直接和 PriceAverager 绑定的，因此说是 Dependency Invertion， 这样做的好处也是显而易见的。</p>
<br>
<p>其实这个例子和 面向接口优于实现 中的例子几乎是一样的，这是因为后者是更抽象的表达。</p>
<br>
<h2>6.知道的越少越好(Least Knowledge)</h2>
<p>这个和  Loose Coupling 其实很类似，但是却是更具体的实现，毕竟低耦合一句话还是太过笼统，设计一个低耦合的系统需要考虑的事情还是很多的。</p>
<br>
<p>现在这个 rule 所说的就是在设计某个类的时候，需要做到让他知道的越少越好，那么究竟是什么不能让他多知道呢？</p>
<p>答案就是其他 class。</p>
<p>根据 HEAD 书所说，在某个具体的 method 中，使用的 Object 必须符合以下条件之一或多个：</p>
<ol start="1"><li>是 this
</li><li>是 method 的参数
</li><li>是 在这个 method 中通过 new 创建的
</li><li>是 this 的某个 member
</li></ol>
<br>
<p>看一个例子就知道了：</p>
<pre><code class='code-multiline'><span class="sf_code_syntax_comment">// Bad Code
</span><span class="sf_code_syntax_project">public</span> <span class="sf_code_syntax_project">float</span> getTemp() {
    <span class="sf_code_syntax_project">Thermometer</span> thermometer <span class="sf_code_syntax_keyword">=</span> station<span class="sf_code_syntax_keyword">.</span>getThermometer(); 
    <span class="sf_code_syntax_keyword">return</span> thermometer<span class="sf_code_syntax_keyword">.</span>getTemperature();
}

<span class="sf_code_syntax_comment">// Good Code
</span><span class="sf_code_syntax_project">public</span> <span class="sf_code_syntax_project">float</span> getTemp() {
    <span class="sf_code_syntax_keyword">return</span> station<span class="sf_code_syntax_keyword">.</span>getTemperature();
}</code></pre>
<p><br></p>
<h2>7.好莱坞法则（Don’t call us, we’ll call you）</h2>
<p>这个是很常见的设计规则，会一下流行的框架，比如 Android SDK，iOS，React，生命周期回调函数，让 high-level component 控制流程， low-level component 控制具体实现。</p>
<br>
<p>在设计模式里，基本上就是 Template Method Pattern 直接对应了这条 rule。</p>
<br>
<h2>8.单一职责(Single Responsibility)</h2>
<p>这个看上 rule 看上去是比较简单，就不多说了，基本上就是一个类不应该实现它不应该具备的功能，否则就会变成 God Object 的了。</p>
<br>
<p>遵守这个 rule 的理由是，如果一个类具备了多个 responsibility，一方面这个类本身就会比较复杂，另一方面改动它的可能性也会很大，改动一个设计复杂的类，实在是很麻烦的一件事情。</p>
<br>
<p>如何遵守这个 rule 呢？</p>
<br>
<p>其实本质上就是分类的能力，将不属于此类的方法分离到其他类去实现。</p>

        </div>
        <script type="text/javascript">
            (function() {

    var doc_ols = document.getElementsByTagName("ol");

    for ( i=0; i<doc_ols.length; i++) {

        var ol_start = doc_ols[i].getAttribute("start") - 1;
        doc_ols[i].setAttribute("style", "counter-reset:ol " + ol_start + ";");

    }

})();
        </script>
        <style>
            html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td,article,aside,canvas,details,embed,figure,figcaption,footer,header,hgroup,menu,nav,output,ruby,section,summary,time,mark,audio,video{margin:0;padding:0;border:0;font:inherit;font-size:100%;vertical-align:baseline}html{line-height:1}ol,ul{list-style:none}table{border-collapse:collapse;border-spacing:0}caption,th,td{text-align:left;font-weight:normal;vertical-align:middle}q,blockquote{quotes:none}q:before,q:after,blockquote:before,blockquote:after{content:"";content:none}a img{border:none}article,aside,details,figcaption,figure,footer,header,hgroup,main,menu,nav,section,summary{display:block}*{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}html{font-size:87.5%;line-height:1.57143em}html{font-size:14px;line-height:1.6em;-webkit-text-size-adjust:100%}body{background:#fcfcfc;color:#545454;text-rendering:optimizeLegibility;font-family:"AvenirNext-Regular"}a{color:#de4c4f;text-decoration:none}h1{font-family:"AvenirNext-Medium";color:#333;font-size:1.6em;line-height:1.3em;margin-bottom:.78571em}h2{font-family:"AvenirNext-Medium";color:#333;font-size:1.3em;line-height:1em;margin-bottom:.62857em}h3{font-family:"AvenirNext-Medium";color:#333;font-size:1.15em;line-height:1em;margin-bottom:.47143em}p{margin-bottom:1.57143em;hyphens:auto}hr{height:1px;border:0;background-color:#dedede;margin:-1px auto 1.57143em auto}ul,ol{margin-bottom:.31429em}ul ul,ul ol,ol ul,ol ol{margin-bottom:0px}ol li:before{content:counter(ol) ".";counter-increment:ol;color:#e06e73;text-align:right;display:inline-block;min-width:1em;margin-right:0.5em}b,strong{font-family:"AvenirNext-Bold"}i,em{font-family:"AvenirNext-Italic"}code{font-family:"Menlo-Regular"}.text-overflow-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.sf_code_syntax_string{color:#D33905}.sf_code_syntax_comment{color:#838383}.sf_code_syntax_documentation_comment{color:#128901}.sf_code_syntax_number{color:#0E73A2}.sf_code_syntax_project{color:#5B2599}.sf_code_syntax_keyword{color:#0E73A2}.sf_code_syntax_character{color:#1B00CE}.sf_code_syntax_preprocessor{color:#920448}.note-wrapper{max-width:46em;margin:0px auto;padding:1.57143em 3.14286em}.note-wrapper.spotlight-preview{overflow-x:hidden}u{text-decoration:none;background-image:linear-gradient(to bottom, rgba(0,0,0,0) 50%,#e06e73 50%);background-repeat:repeat-x;background-size:2px 2px;background-position:0 1.05em}s{color:#878787}p{margin-bottom:0.1em}hr{margin-bottom:0.7em;margin-top:0.7em}ul li{text-indent:-0.35em}ul li:before{content:"•";color:#e06e73;display:inline-block;margin-right:0.3em}ul ul{margin-left:1.25714em}ol li{text-indent:-1.45em}ol ol{margin-left:1.25714em}blockquote{display:block;margin-left:-1em;padding-left:0.8em;border-left:0.2em solid #e06e73}.todo-list ul{margin-left:1.88571em}.todo-list li{text-indent:-1.75em}.todo-list li:before{content:"";display:static;margin-right:0px}.todo-checkbox{text-indent:-1.7em}.todo-checkbox svg{margin-right:0.3em;position:relative;top:0.2em}.todo-checkbox svg #check{display:none}.todo-checkbox.todo-checked #check{display:inline}.todo-checkbox.todo-checked .todo-text{text-decoration:line-through;color:#878787}.code-inline{display:inline;background:white;border:solid 1px #dedede;padding:0.2em 0.5em;font-size:0.9em}.code-multiline{display:block;background:white;border:solid 1px #dedede;padding:0.7em 1em;font-size:0.9em;overflow-x:auto}.hashtag{display:inline-block;color:white;background:#b8bfc2;padding:0.0em 0.5em;border-radius:1em;text-indent:0}.hashtag a{color:#fff}.address a{color:#545454;background-image:linear-gradient(to bottom, rgba(0,0,0,0) 50%,#0da35e 50%);background-repeat:repeat-x;background-size:2px 2px;background-position:0 1.05em}.address svg{position:relative;top:0.2em;display:inline-block;margin-right:0.2em}.color-preview{display:inline-block;width:1em;height:1em;border:solid 1px rgba(0,0,0,0.3);border-radius:50%;margin-right:0.1em;position:relative;top:0.2em;white-space:nowrap}.color-code{margin-right:0.2em;font-family:"Menlo-Regular";font-size:0.9em}.color-hash{opacity:0.4}.ordered-list-number{color:#e06e73;text-align:right;display:inline-block;min-width:1em}.arrow svg{position:relative;top:0.08em;display:inline-block;margin-right:0.15em;margin-left:0.15em}.arrow svg #rod{stroke:#545454}.arrow svg #point{fill:#545454}mark{color:inherit;display:inline-block;padding:0px 4px;background-color:#fcffc0}img{max-width:100%;height:auto}

        </style>
    </body>
</html>
