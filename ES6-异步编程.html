<!DOCTYPE html>
<html>
    <head>
        <title>ES6-异步编程</title>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="created" content="2018-02-22T21:39:06+0800"/>
        <meta name="modified" content="2018-02-22T21:51:28+0800"/>
        <meta name="tags" content="web"/>
        <meta name="last device" content="xwei's MBP"/>
    </head>
    <body>
        <div class="note-wrapper">
            <h1>ES6-异步编程</h1>
<p><span class='hashtag'>#web</span></p>
<hr>
<p>title: ES6-异步编程</p>
<p>date: 2017-04-03 00:36:55</p>
<hr>
<h2>Abstract</h2>
<p>异步编程是 Javascript 的一大特色，因为 Javascript 是单线程工作，因此如果没有异步方式的话，基本上用户体验将会是无法忍受的。</p>
<br>
<p>因此 Javascript 的语法对异步的看重使得其对异步编程用了比较大的力气去优化，本文将会对直到 ES7 的异步编程方式进行总结：</p>
<ol start="1"><li>Callback
</li><li>Promise
</li><li>Generator
</li><li>asyn + await
</li></ol>
<br>
<p>但是在阐述这些方式之前，有一个概念需要事先阐述的是 Javascript 的事件循环。</p>
<br>
<h2>事件循环(event loop)</h2>
<p>event loop 是 Javascript 作为单线程语言完成非阻塞处理的重要机制，但其本身很容易理解，就是 Javascript 解释器的实现中会维护一个队列，task queue，当在执行语句中出现异步函数（比如 setTimeout）的时候，这样的函数是不会立即执行的，而是会被挂起，当空闲的时候，Javascript 解释器会处理这个异步操作，当处理完毕后，会在 task queue 里面插入一个事件，这个事件一般绑定了定义好的 callback。</p>
<br>
<p>下面是一个最简单的一个例子是：</p>
<br>
<pre><code class='code-multiline'><span class="sf_code_syntax_keyword">setTimeout</span>(()<span class="sf_code_syntax_keyword">=&gt;console</span>.log(<span class="sf_code_syntax_string">'World'</span>), <span class="sf_code_syntax_number">0</span>)
<span class="sf_code_syntax_keyword">console</span>.log(<span class="sf_code_syntax_string">'Hello'</span>)
<span class="sf_code_syntax_comment">// output: "Hello\nWorld" </span></code></pre>
<p><br></p>
<p>结果是在意料之中的，这是因为当调用 setTimeout 函数时，你即使设置了 timeout 是 0ms，callback 函数的执行仍然会被放入 task queue 里，等到当前的 call stack 被清空后（这里停止的时机我还不是很清楚，可能是 call stack 清空，但也可能是其他判定条件，比如跑了指定长度的代码）再回来从 task queue 里面取出最新的 event 来处理，也就是执行回调。</p>
<br>
<h2>异步编程方式</h2>
<p>有了 event loop 这个概念，那么对于操作异步函数就有帮助了，下面总结异步编程的方式，为了便于说明和调试，在需要使用异步函数的时候，本文都会使用 setTimeout 这个异步函数，其实本质上他和其他异步函数没什么区别，如果设置了 timeout 参数，就可看成其他异步函数的工作时间（这和 Java 中使用 Thread.sleep() 模拟线程运行是一个道理），下面会罗列目前 Javascript 的异步处理的几种常见的方式。</p>
<br>
<p>由于 setTimeout 的书写方式和正常异步函数不一致，此外不想在每次写 setTimeout 的时候，总是设置 timeout，所以先将其包装一下：</p>
<br>
<pre><code class='code-multiline'><span class="sf_code_syntax_project">var</span> afunc <span class="sf_code_syntax_keyword">=</span> (callback) <span class="sf_code_syntax_keyword">=&gt;</span> <span class="sf_code_syntax_keyword">setTimeout</span>(callback,<span class="sf_code_syntax_number">1000</span>)
</code></pre>此外，需要强调的是，这里所说的是异步编程方式，而不是异步函数，所谓异步编程方式（Asynchronized Programming)是指编写含有异步函数的代码的方式。

<h3>Callback</h3>
所谓的 Callback 是最原始的方式，也就说说直接将 callback 函数作为异步函数的参数传入，比如：
<pre><code class='code-multiline'>afunc(()<span class="sf_code_syntax_keyword">=&gt;</span>{
    <span class="sf_code_syntax_keyword">console</span>.log(<span class="sf_code_syntax_string">"Hello"</span>);
    afunc(()<span class="sf_code_syntax_keyword">=&gt;</span>{
        <span class="sf_code_syntax_keyword">console</span>.log(<span class="sf_code_syntax_string">"World"</span>);
        afunc(()<span class="sf_code_syntax_keyword">=&gt;console</span>.log(<span class="sf_code_syntax_string">"!"</span>));
    })
})
<span class="sf_code_syntax_comment">//output: Hello\nWorld\n!</span></code></pre>
<p><br></p>
<p>当然如果写成原来的样子，应该是：</p>
<br>
<pre><code class='code-multiline'><span class="sf_code_syntax_keyword">setTimeout</span>(()<span class="sf_code_syntax_keyword">=&gt;</span>{
    <span class="sf_code_syntax_keyword">console</span>.log(<span class="sf_code_syntax_string">"Hello"</span>);
    <span class="sf_code_syntax_keyword">setTimeout</span>(()<span class="sf_code_syntax_keyword">=&gt;</span>{
        <span class="sf_code_syntax_keyword">console</span>.log(<span class="sf_code_syntax_string">"World"</span>);
        <span class="sf_code_syntax_keyword">setTimeout</span>(()<span class="sf_code_syntax_keyword">=&gt;console</span>.log(<span class="sf_code_syntax_string">'!'</span>),<span class="sf_code_syntax_number">1000</span>);
    },<span class="sf_code_syntax_number">1000</span>)
},<span class="sf_code_syntax_number">1000</span>)</code></pre>
<p><br></p>
<p>(之后就会直接使用 afunc)</p>
<p>可以发现这样写不很方便，而且很丑，于是在 ES6 中 Promise 应运而生。</p>
<br>
<h3>Promise</h3>
<p>Promise 会提供刚好的异步编程体验，同样的例子可以这么写：</p>
<pre><code class='code-multiline'><span class="sf_code_syntax_keyword">new</span> <span class="sf_code_syntax_keyword">Promise</span>((resolve,reject)<span class="sf_code_syntax_keyword">=&gt;</span>{
    afunc(()<span class="sf_code_syntax_keyword">=&gt;</span>{<span class="sf_code_syntax_keyword">console</span>.log(<span class="sf_code_syntax_string">"Hello"</span>);resolve();})
}).then(()<span class="sf_code_syntax_keyword">=&gt;new</span> <span class="sf_code_syntax_keyword">Promise</span>((resolve)<span class="sf_code_syntax_keyword">=&gt;</span>afunc(()<span class="sf_code_syntax_keyword">=&gt;</span>{<span class="sf_code_syntax_keyword">console</span>.log(<span class="sf_code_syntax_string">"World"</span>);resolve()})))
.then(()<span class="sf_code_syntax_keyword">=&gt;new</span> <span class="sf_code_syntax_keyword">Promise</span>((resolve)<span class="sf_code_syntax_keyword">=&gt;</span>afunc(()<span class="sf_code_syntax_keyword">=&gt;</span>{<span class="sf_code_syntax_keyword">console</span>.log(<span class="sf_code_syntax_string">"!"</span>);resolve()})))</code></pre>
<p><br></p>
<p>这样就写成了链式的调用，但看上去非常繁琐，实际上我们可以将 afunc 封装一下：(为了不起冲突，命名成 afuncp)</p>
<pre><code class='code-multiline'><span class="sf_code_syntax_project">var</span> afuncp <span class="sf_code_syntax_keyword">=</span> (callback)<span class="sf_code_syntax_keyword">=&gt;</span>{
    <span class="sf_code_syntax_keyword">return</span> <span class="sf_code_syntax_keyword">new</span> <span class="sf_code_syntax_keyword">Promise</span>((resolve)<span class="sf_code_syntax_keyword">=&gt;</span>{
        <span class="sf_code_syntax_keyword">setTimeout</span>(()<span class="sf_code_syntax_keyword">=&gt;</span>{
            callback();resolve()
            }, <span class="sf_code_syntax_number">1000</span>);
    })
}

<span class="sf_code_syntax_comment">// then the statement can be expressed as:
</span>afuncp(()<span class="sf_code_syntax_keyword">=&gt;console</span>.log(<span class="sf_code_syntax_string">"Hello"</span>))
.then(()<span class="sf_code_syntax_keyword">=&gt;</span>afuncp(()<span class="sf_code_syntax_keyword">=&gt;console</span>.log(<span class="sf_code_syntax_string">"World"</span>)))
.then(()<span class="sf_code_syntax_keyword">=&gt;</span>afuncp(()<span class="sf_code_syntax_keyword">=&gt;console</span>.log(<span class="sf_code_syntax_string">"!"</span>)))</code></pre>
<p><br></p>
<p>是不是简洁多了？</p>
<p>这里的改写实际上和 fs 中的 readFile 和 fs-readfile-promise 类似。</p>
<br>
<p>但即使如此，还有更方便的写法。</p>
<br>
<h3>Generator</h3>
<p>如果能把异步编程的方式写成同步形式，那岂不是更加美观？</p>
<br>
<p>Generator 应运而生。</p>
<br>
<p>如果使用 Generator 的话，上面的写法将会变成：（注意这里使用的是 afuncp 而不是 afunc，当然使用 afunc 也是可以的，但是在下面要使用 Promise 的特性时就行不通了）</p>
<pre><code class='code-multiline'><span class="sf_code_syntax_project">function</span><span class="sf_code_syntax_keyword">*</span> <span class="sf_code_syntax_character">genHelloWorld</span>(){
    <span class="sf_code_syntax_keyword">yield</span> afuncp(()<span class="sf_code_syntax_keyword">=&gt;console</span>.log(<span class="sf_code_syntax_string">"Hello"</span>));
    <span class="sf_code_syntax_keyword">yield</span> afuncp(()<span class="sf_code_syntax_keyword">=&gt;console</span>.log(<span class="sf_code_syntax_string">"World"</span>));
    <span class="sf_code_syntax_keyword">yield</span> afuncp(()<span class="sf_code_syntax_keyword">=&gt;console</span>.log(<span class="sf_code_syntax_string">"!"</span>));
}

<span class="sf_code_syntax_project">var</span> g <span class="sf_code_syntax_keyword">=</span> genHelloWorld();
g.next()
g.next()
g.next()</code></pre>
<p><br></p>
<p>但是这么写却是不对的，（你可以发现三个字符串是同时出现的）为什么呢？因为虽然通过利用 Generator 执行到下一个 yield 会停止的特性来做到了，这样顺序执行了三个异步操作，但是和之前两个异步操作不一样，因为我们之前写的异步操作是有先后关系的，后一个异步操作必须是在前一个异步操作完成之后才能执行的。</p>
<br>
<p>也就是说 Generator 其实本身不支持异步操作的依赖执行（就是前一个先执行了，才能执行下一个），但是具备记录上次执行位置和状态使得它有可能完成异步编程方式，而其所欠缺的只是一个使得依赖执行能够运作的机制（姑且成为依赖运行器）。</p>
<br>
<p>下面我们就来实现这个机制，这个机制的关键地方在于控制依赖，以及自动运行：</p>
<pre><code class='code-multiline'><span class="sf_code_syntax_project">function</span> <span class="sf_code_syntax_character">genController</span>(gen){
    <span class="sf_code_syntax_project">let</span> g <span class="sf_code_syntax_keyword">=</span> gen();
    <span class="sf_code_syntax_project">function</span> <span class="sf_code_syntax_character">next</span>(){
        <span class="sf_code_syntax_project">let</span> res <span class="sf_code_syntax_keyword">=</span> g.next();
        <span class="sf_code_syntax_keyword">if</span>(<span class="sf_code_syntax_keyword">!</span>res.done){
            res.value.then(next);
        }
    }
    next();
}

<span class="sf_code_syntax_comment">// now let's run genHelloWorld
</span>genContorller(genHelloWorld);
</code></pre>如果想在 production 环境中使用这样的机制，可以考虑 co 这个模块。

<h3>async + await</h3>
通过上面的例子可以看出来，Generator 虽然在表达异步编程上非常具有优势，但是容易发现需要自己定义依赖运行器，于是 async 函数应运而生，其本质还是 Generator 但是却自带了依赖运行器。
下面试试，async 的写法：
<pre><code class='code-multiline'>async <span class="sf_code_syntax_project">function</span> <span class="sf_code_syntax_character">genHelloWorld</span>() {
    await afuncp(()<span class="sf_code_syntax_keyword">=&gt;console</span>.log(<span class="sf_code_syntax_string">"Hello"</span>));
    await afuncp(()<span class="sf_code_syntax_keyword">=&gt;console</span>.log(<span class="sf_code_syntax_string">"World"</span>));
    await afuncp(()<span class="sf_code_syntax_keyword">=&gt;console</span>.log(<span class="sf_code_syntax_string">"!"</span>));
}
genHelloWorld();
</code></pre>很完美！

<h3>Promise 的实现</h3>

之前有个工作上的前辈让我实现一个 Promise，叫我半个小时写出来一个有 resolve、then 功能的 Promise 类，结果我花了一晚上才实现出来。
代码如下：
<pre><code class='code-multiline'>class PPromise {
    constructor(asyncF) {
        <span class="sf_code_syntax_keyword">this</span>.cb <span class="sf_code_syntax_keyword">=</span> <span class="sf_code_syntax_number">null</span>; 
        <span class="sf_code_syntax_keyword">this</span>.resolve <span class="sf_code_syntax_keyword">=</span> <span class="sf_code_syntax_keyword">this</span>.resolve.bind(<span class="sf_code_syntax_keyword">this</span>);
        <span class="sf_code_syntax_keyword">this</span>.then <span class="sf_code_syntax_keyword">=</span> <span class="sf_code_syntax_keyword">this</span>.then.bind(<span class="sf_code_syntax_keyword">this</span>);
        <span class="sf_code_syntax_comment">// convert resolve to async function calling
</span>        asyncF.apply(<span class="sf_code_syntax_number">null</span>, [(data)<span class="sf_code_syntax_keyword">=&gt;setTimeout</span>(()<span class="sf_code_syntax_keyword">=&gt;this</span>.resolve(data),<span class="sf_code_syntax_number">0</span>)])
    }

    resolve(data) {
            <span class="sf_code_syntax_project">var</span> cb <span class="sf_code_syntax_keyword">=</span> <span class="sf_code_syntax_keyword">this</span>.cb;
            <span class="sf_code_syntax_keyword">if</span> (cb<span class="sf_code_syntax_keyword">!==</span><span class="sf_code_syntax_number">null</span>)
                cb.apply(<span class="sf_code_syntax_number">null</span>,[data]);
    }

    then(cb) {
        <span class="sf_code_syntax_project">var</span> newPromise <span class="sf_code_syntax_keyword">=</span> <span class="sf_code_syntax_keyword">new</span> <span class="sf_code_syntax_keyword">PPromise</span>(()<span class="sf_code_syntax_keyword">=&gt;</span><span class="sf_code_syntax_number">null</span>);
        <span class="sf_code_syntax_comment">// link the next promise in the cb
</span>        <span class="sf_code_syntax_keyword">this</span>.cb <span class="sf_code_syntax_keyword">=</span> (data)<span class="sf_code_syntax_keyword">=&gt;</span>{
            <span class="sf_code_syntax_project">var</span> d <span class="sf_code_syntax_keyword">=</span> cb.apply(<span class="sf_code_syntax_number">null</span>,[data]) 
            newPromise.resolve(d); 
        }   
        <span class="sf_code_syntax_keyword">return</span> newPromise;
    }
}
</code></pre>实现的时候有两点需要注意的是：
<ol start="1"><li>new Promise((resolve)=>resolve(data)).then(console.log) 这个 resolve 调用是会被挂起的，这点也是这行代码
</li></ol>
<p> <code class='code-inline'>asyncF.apply(null, [(data)=&gt;setTimeout(()=&gt;this.resolve(data),0)])</code> </p>
<p>的作用。</p>
<ol start="3"><li>then 返回的是一个什么？ 答案是还是一个 Promise，这里的实现是返回一个新的 Promise 然后在当前 Promise 的 callback 中调用新 Promise 的 resolve 方法。</li></ol>

        </div>
        <script type="text/javascript">
            (function() {

    var doc_ols = document.getElementsByTagName("ol");

    for ( i=0; i<doc_ols.length; i++) {

        var ol_start = doc_ols[i].getAttribute("start") - 1;
        doc_ols[i].setAttribute("style", "counter-reset:ol " + ol_start + ";");

    }

})();
        </script>
        <style>
            html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td,article,aside,canvas,details,embed,figure,figcaption,footer,header,hgroup,menu,nav,output,ruby,section,summary,time,mark,audio,video{margin:0;padding:0;border:0;font:inherit;font-size:100%;vertical-align:baseline}html{line-height:1}ol,ul{list-style:none}table{border-collapse:collapse;border-spacing:0}caption,th,td{text-align:left;font-weight:normal;vertical-align:middle}q,blockquote{quotes:none}q:before,q:after,blockquote:before,blockquote:after{content:"";content:none}a img{border:none}article,aside,details,figcaption,figure,footer,header,hgroup,main,menu,nav,section,summary{display:block}*{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}html{font-size:87.5%;line-height:1.57143em}html{font-size:14px;line-height:1.6em;-webkit-text-size-adjust:100%}body{background:#fcfcfc;color:#545454;text-rendering:optimizeLegibility;font-family:"AvenirNext-Regular"}a{color:#de4c4f;text-decoration:none}h1{font-family:"AvenirNext-Medium";color:#333;font-size:1.6em;line-height:1.3em;margin-bottom:.78571em}h2{font-family:"AvenirNext-Medium";color:#333;font-size:1.3em;line-height:1em;margin-bottom:.62857em}h3{font-family:"AvenirNext-Medium";color:#333;font-size:1.15em;line-height:1em;margin-bottom:.47143em}p{margin-bottom:1.57143em;hyphens:auto}hr{height:1px;border:0;background-color:#dedede;margin:-1px auto 1.57143em auto}ul,ol{margin-bottom:.31429em}ul ul,ul ol,ol ul,ol ol{margin-bottom:0px}ol li:before{content:counter(ol) ".";counter-increment:ol;color:#e06e73;text-align:right;display:inline-block;min-width:1em;margin-right:0.5em}b,strong{font-family:"AvenirNext-Bold"}i,em{font-family:"AvenirNext-Italic"}code{font-family:"Menlo-Regular"}.text-overflow-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.sf_code_syntax_string{color:#D33905}.sf_code_syntax_comment{color:#838383}.sf_code_syntax_documentation_comment{color:#128901}.sf_code_syntax_number{color:#0E73A2}.sf_code_syntax_project{color:#5B2599}.sf_code_syntax_keyword{color:#0E73A2}.sf_code_syntax_character{color:#1B00CE}.sf_code_syntax_preprocessor{color:#920448}.note-wrapper{max-width:46em;margin:0px auto;padding:1.57143em 3.14286em}.note-wrapper.spotlight-preview{overflow-x:hidden}u{text-decoration:none;background-image:linear-gradient(to bottom, rgba(0,0,0,0) 50%,#e06e73 50%);background-repeat:repeat-x;background-size:2px 2px;background-position:0 1.05em}s{color:#878787}p{margin-bottom:0.1em}hr{margin-bottom:0.7em;margin-top:0.7em}ul li{text-indent:-0.35em}ul li:before{content:"•";color:#e06e73;display:inline-block;margin-right:0.3em}ul ul{margin-left:1.25714em}ol li{text-indent:-1.45em}ol ol{margin-left:1.25714em}blockquote{display:block;margin-left:-1em;padding-left:0.8em;border-left:0.2em solid #e06e73}.todo-list ul{margin-left:1.88571em}.todo-list li{text-indent:-1.75em}.todo-list li:before{content:"";display:static;margin-right:0px}.todo-checkbox{text-indent:-1.7em}.todo-checkbox svg{margin-right:0.3em;position:relative;top:0.2em}.todo-checkbox svg #check{display:none}.todo-checkbox.todo-checked #check{display:inline}.todo-checkbox.todo-checked .todo-text{text-decoration:line-through;color:#878787}.code-inline{display:inline;background:white;border:solid 1px #dedede;padding:0.2em 0.5em;font-size:0.9em}.code-multiline{display:block;background:white;border:solid 1px #dedede;padding:0.7em 1em;font-size:0.9em;overflow-x:auto}.hashtag{display:inline-block;color:white;background:#b8bfc2;padding:0.0em 0.5em;border-radius:1em;text-indent:0}.hashtag a{color:#fff}.address a{color:#545454;background-image:linear-gradient(to bottom, rgba(0,0,0,0) 50%,#0da35e 50%);background-repeat:repeat-x;background-size:2px 2px;background-position:0 1.05em}.address svg{position:relative;top:0.2em;display:inline-block;margin-right:0.2em}.color-preview{display:inline-block;width:1em;height:1em;border:solid 1px rgba(0,0,0,0.3);border-radius:50%;margin-right:0.1em;position:relative;top:0.2em;white-space:nowrap}.color-code{margin-right:0.2em;font-family:"Menlo-Regular";font-size:0.9em}.color-hash{opacity:0.4}.ordered-list-number{color:#e06e73;text-align:right;display:inline-block;min-width:1em}.arrow svg{position:relative;top:0.08em;display:inline-block;margin-right:0.15em;margin-left:0.15em}.arrow svg #rod{stroke:#545454}.arrow svg #point{fill:#545454}mark{color:inherit;display:inline-block;padding:0px 4px;background-color:#fcffc0}img{max-width:100%;height:auto}

        </style>
    </body>
</html>
