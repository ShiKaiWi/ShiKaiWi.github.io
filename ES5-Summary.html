<!DOCTYPE html>
<html>
    <head>
        <title>ES5-Summary</title>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="created" content="2018-02-22T22:11:23+0800"/>
        <meta name="modified" content="2018-02-22T22:14:31+0800"/>
        <meta name="tags" content=""/>
        <meta name="last device" content="xwei's MBP"/>
    </head>
    <body>
        <div class="note-wrapper">
            <h1>ES5-Summary</h1>
<hr>
<p>title: ES5 Summary</p>
<p>date: 2017-02-17 00:05:46</p>
<hr>
<br>
<h2>Abstract</h2>
<p>JavaScript 的语法让我感到非常不舒服，究其原因其实是因为两点：</p>
<ol start="1"><li>动态语言
</li><li>原型编程
</li></ol>
<br>
<p>对于动态语言，我个人始终认为是不符合大型 project 的要求的，因为动态语言的特性导致阅读代码的时候非常不顺利，比如你看到一个 function 的参数时候，你完全不知道它是怎样的结构，但是像 Java 这样的强类型语言，每一个参数都有类型，就使得对于每一个参数你都知道它实实在在的含义（可以去查看参数类型的定义）。</p>
<p>此外原型编程，我迄今看不出其优势所在，不仅每一个对象的原型都可以被随意改变，而且根本没有访问控制。</p>
<br>
<p>但尽管如此，我个人认为 JavaScript 还是更加现代化的编程语言，比如它的 function 可以作为对象任意传递，这一点和 Python 类似，对于异步编程可以说是非常直观地支持。</p>
<p>然而 JavaScript 的发展在 2015 年 ES6 发布后，就迎来了非常大的增强，我想为了更好的学习 ES6，对之前版本的深层次的理解还是需要的，相当于打好基础才能更好地前进。</p>
<p>在本篇 post 中，我主要是对自己看过的 Dmitry Soshnikov 的一系列关于 ES3-ES5 的 <a href="http://dmitrysoshnikov.com">posts</a> 总结，主要包含 JavaScript 中最迷惑人的两个部分：</p>
<ol start="1"><li>变量管理
</li><li>原型编程
</li></ol>
<br>
<h2>变量管理</h2>
<p>这里使用的变量管理并不是指硬件层面的实现，而是指 JavaScript 的变量存储的抽象模型。另外，在概念上，ES3 和 ES5 有着几个区别，因此会分别描述。</p>
<br>
<h3>ES3</h3>
<h4>Execution Context(EC)</h4>
<p>在 JavaScript 中有两种 EC：global context 和 function context。</p>
<p>不同的 context 的管理是用 stack 模式管理的，举个例子，在 global context 下定义了一个 function func，那么整个 EC stack 就是：</p>
<pre><code class='code-multiline'>EC Stack = {
    funcContext,
    globalContext,
}
</code></pre>如果从 funcContext 退出那么，EC Stack 将会只剩下 globalContext，符合 Stack 的管理方式。
EC 有着许多重要的 property，用以在运行时使用，而在本篇 post 中，着重强调变量管理这一个问题，因此会探究其相关属性。

<h4>Variable Object(VO) / Activation Object(AO)</h4>
VO 和 AO 其实类似于符号表(symbol table)，用以集中管理变量，并且这是 EC 的属性，在 ES6 之前是没有 var 之外的变量定义方式的(有隐式定义变量，下面会提到)，而对 var 的处理会在静态分析进行，并且将定义的变量名填入 VO/AO，但是并不会直接对其赋值，而是等到执行到赋值语句的时候才会：
<pre><code class='code-multiline'><span class="sf_code_syntax_comment">// now VO = {
//     a: undefined,
// }
</span>
<span class="sf_code_syntax_keyword">console</span>.log(a); <span class="sf_code_syntax_comment">// undefined
</span><span class="sf_code_syntax_project">var</span> a <span class="sf_code_syntax_keyword">=</span> <span class="sf_code_syntax_number">13</span>;

<span class="sf_code_syntax_comment">// now VO = {
//     a: 13,
// }</span></code></pre>
<p><br></p>
<p>这里既然都是符号表，为什么有 VO 和 AO 的区别呢？</p>
<p>VO 其实是指 global context 的符号表，而 AO 是指 function context 的符号表，之所以有这两者的区别是因为 function context 有着不一样的符号管理，总共包括三类符号：</p>
<ol start="1"><li>arguments：即 function 的参数
</li><li>functions：function 内部定义的 function，在静态分析期间，如果符号与 arguments、variables 中的有冲突，直接替代(function 提升)
</li><li>variables：function 内部定义的变量，如果和 1、2 有冲突，在静态分析期间不会造成影响，在执行期间会直接替代 1 中的冲突项(理所当然的，后来覆盖)，与 2 的互相替代也符合后来覆盖原则
</li></ol>
<br>
<p>直接看一个例子就知道区别了：</p>
<pre><code class='code-multiline'><span class="sf_code_syntax_project">function</span> <span class="sf_code_syntax_character">func</span>(f){
    <span class="sf_code_syntax_keyword">console</span>.log(f);
    <span class="sf_code_syntax_project">var</span> f <span class="sf_code_syntax_keyword">=</span> <span class="sf_code_syntax_number">4</span>;
    <span class="sf_code_syntax_project">function</span> <span class="sf_code_syntax_character">f</span>(){}
    <span class="sf_code_syntax_keyword">console</span>.log(f);
}
func(<span class="sf_code_syntax_number">3</span>);
<span class="sf_code_syntax_comment">// output:
// [Function: f]
// 4</span></code></pre>
<p><br></p>
<p>这段的最后还要说明一下隐式声明的问题，上面提到如果直接给一个变量赋值(不用 var)也是可以的，但是其实不是向 VO 中添加符号，而是给当前的 EC 下的 this 变量添加了一个属性而已。</p>
<p>看下面的例子：</p>
<pre><code class='code-multiline'>x <span class="sf_code_syntax_keyword">=</span> <span class="sf_code_syntax_number">3</span>;
<span class="sf_code_syntax_project">var</span> a <span class="sf_code_syntax_keyword">=</span> <span class="sf_code_syntax_number">4</span>;
<span class="sf_code_syntax_keyword">delete</span> a;
<span class="sf_code_syntax_keyword">delete</span> x;
<span class="sf_code_syntax_keyword">console</span>.log(a); <span class="sf_code_syntax_comment">// 4
</span><span class="sf_code_syntax_keyword">console</span>.log(x); <span class="sf_code_syntax_comment">// Reference Error</span></code></pre>
<p><br></p>
<h3>Scope Chain(SC)</h3>
<p>按道理说有了 EC 和 VO，那么便可以在任何一个特定的 EC 下进行变量访问，但是如果出现当前变量无法再当前 EC 下找到，那么该如何处理呢？为了解决这种情况，SC 被引入自然是很正常的事情，而 SC 和其他语言的构造方法基本一致：</p>
<pre><code class='code-multiline'>SC(ECStack[<span class="sf_code_syntax_keyword">top</span>]) <span class="sf_code_syntax_keyword">=</span> VO/AO <span class="sf_code_syntax_keyword">+</span> SC(ECStack[<span class="sf_code_syntax_keyword">top-</span><span class="sf_code_syntax_number">1</span>]);
ECStack[<span class="sf_code_syntax_number">0</span>] <span class="sf_code_syntax_keyword">===</span> globalContext;</code></pre>
<p><br></p>
<p>但需要注意的是，JavaScript 并没有 block 的概念，这是和其他主流语言的最大区别之一，也正因为如此只有 function 才能创造新的 context，因此常常会说一个 function 的 SC，但实际上是 EC 的 SC。因此对于 function 中的变量解析，自然是很重要的，但其实也很简单，只需要注意一点 function 的 SC 是静态分析确立的，会在运行前把需要用的变量的 Reference 记录下来：</p>
<pre><code class='code-multiline'><span class="sf_code_syntax_project">var</span> x <span class="sf_code_syntax_keyword">=</span> <span class="sf_code_syntax_number">3</span>;
<span class="sf_code_syntax_project">function</span> <span class="sf_code_syntax_character">func</span>(){
    <span class="sf_code_syntax_keyword">console</span>.log(x);
}
func(); <span class="sf_code_syntax_comment">// output: 3
</span>x <span class="sf_code_syntax_keyword">=</span> <span class="sf_code_syntax_number">4</span>;
func(); <span class="sf_code_syntax_comment">// output: 4</span></code></pre>
<p><br></p>
<p>此外，with 和 catch 会把其引入的变量加入到当前 SC 的最前面:</p>
<pre><code class='code-multiline'><span class="sf_code_syntax_project">function</span> <span class="sf_code_syntax_character">func</span>(){
    <span class="sf_code_syntax_project">var</span> obj  <span class="sf_code_syntax_keyword">=</span> {
        <span class="sf_code_syntax_character">x</span>: <span class="sf_code_syntax_number">3</span>,
    }
    <span class="sf_code_syntax_project">var</span> x <span class="sf_code_syntax_keyword">=</span> <span class="sf_code_syntax_number">4</span>;
    <span class="sf_code_syntax_keyword">with</span>(obj){
        <span class="sf_code_syntax_keyword">console</span>.log(x);
    }
}
func();<span class="sf_code_syntax_comment">// output: 3</span></code></pre>
<p><br></p>
<p>还有一点比较重要的是，因为 JavaScript 的有着 prototype，因此当顺着 SC 找到最后，可以访问到 Object 的 prototype 上去，可以看下面这个例子：</p>
<pre><code class='code-multiline'><span class="sf_code_syntax_project">function</span> <span class="sf_code_syntax_character">foo</span>() {
  <span class="sf_code_syntax_keyword">console</span>.log(x);
}
<span class="sf_code_syntax_keyword">Object</span>.<span class="sf_code_syntax_keyword">prototype</span>.x <span class="sf_code_syntax_keyword">=</span> <span class="sf_code_syntax_number">10</span>;
foo(); <span class="sf_code_syntax_comment">// 10</span></code></pre>
<p><br></p>
<h4>属性访问</h4>
<p>讲到这里，有了 EC、VO、SC，我们看似便可以对几乎所有的变量进行访问了，但是还有一种情况没有考虑，那就是 object 的属性访问，而在属性访问中，还有一个特别的例子，就是 this 的属性访问。</p>
<br>
<h5>Reference Type(RT)</h5>
<p>属性访问问题解决的本质其实在于如何定义这样的访问方法，而 JS 的做法是通过 RT 来解决，RT 的产生只在两者情况下：</p>
<ol start="1"><li>处理变量名(identifier)[这里表明，普通变量的访问其实也是通过 RT 来解决的]
</li><li>处理属性访问符(property accessor)
</li></ol>
<br>
<p>而 RT 的基本结构如下：</p>
<pre><code class='code-multiline'><span class="sf_code_syntax_project">var</span> foo <span class="sf_code_syntax_keyword">=</span> <span class="sf_code_syntax_number">3</span>;
<span class="sf_code_syntax_comment">// fooReferenceType = {
//    base: null,  =&gt; null will be transformed to globalContext's VO
//    propertyName: foo,
//}</span></code></pre>
<p><br></p>
<p>当引用 foo 变量的时候，首先便会得到一个 fooReferenceType，然后每一个 RT 都有一个获取属性值的方法(GetValue)，这样就解决了属性访问的问题(其实说到可以发现，JS 里所有的变量访问都是属性访问，只不过没有指定 object 的地方基本上使用的 SC 上一层 VO/AO)。</p>
<br>
<h5>this 绑定</h5>
<p>this 的使用一般是如下情况：</p>
<pre><code class='code-multiline'><span class="sf_code_syntax_project">function</span> <span class="sf_code_syntax_character">func</span>() {
    <span class="sf_code_syntax_keyword">console</span>.log(<span class="sf_code_syntax_keyword">this</span>.x);
}
<span class="sf_code_syntax_project">var</span> obj <span class="sf_code_syntax_keyword">=</span> {<span class="sf_code_syntax_character">x</span>:<span class="sf_code_syntax_number">1</span>};
obj.func();</code></pre>
<p><br></p>
<p>这里在 func 的内部如何知道 this 这个 object 是什么呢？这里就涉及到了 this 的 binding 问题。</p>
<p>其实 this 的绑定规则很简单，可以这么说 this 的绑定完全由 function 的调用方式决定，这是因为 this 绑定的 object 就是 function 前面的变量的 RT 的 base。</p>
<pre><code class='code-multiline'><span class="sf_code_syntax_project">var</span> obj1 <span class="sf_code_syntax_keyword">=</span> {
    <span class="sf_code_syntax_character">x</span>: <span class="sf_code_syntax_number">1</span>,
    <span class="sf_code_syntax_character">func</span>:<span class="sf_code_syntax_project">function</span>() {
        <span class="sf_code_syntax_keyword">console</span>.log(<span class="sf_code_syntax_keyword">this</span>.x);
        },
};
<span class="sf_code_syntax_project">var</span> obj2 <span class="sf_code_syntax_keyword">=</span> {
    <span class="sf_code_syntax_character">x</span>: <span class="sf_code_syntax_number">2</span>,
    <span class="sf_code_syntax_character">func</span>: <span class="sf_code_syntax_number">undefined</span>,
};
obj1.func(); <span class="sf_code_syntax_comment">// output 1
</span>obj2.func <span class="sf_code_syntax_keyword">=</span> obj1.func;
obj2.func(); <span class="sf_code_syntax_comment">// output 2
</span>(obj2.func <span class="sf_code_syntax_keyword">=</span> obj1.func)(); <span class="sf_code_syntax_comment">// output undefined</span></code></pre>
<p><br></p>
<p>这是一个很经典的例子，1 和 2 的输出根据上面的理论是理所当然的结果，但是最后一个 undefined 的结果可能就有点令人费解了。它背后的机制是这样的，<code class='code-inline'>(obj2.func = obj1.func)</code> 括号内一个表达式，并不是一个变量名(identifier)，当然也不是属性访问器(property accessor)，因此对它解析不会产生 RT，也因此其 this 的绑定为 null，而 null 作为 this 的值在 non-strict 模式下是会被转化成 globalContext 的 VO 的。</p>
<br>
<h2>ES5</h2>
<h3>Call Stack</h3>
<p>将 EC 的称谓正式变为 Call Stack，本质并没有太多变化。</p>
<br>
<h3>Environment</h3>
<p>ES5 管理变量的方式发生了比较大的变化，首先不在使用 VO 和 AO 了，统一成了 Environment，但是 Environment 分为两类，Variable Environment(VE) 和 Lexical Environment(LE) 两种，但是和 VO<i>AO 的分类并没有直接关系，其实 VE 本质上和 ES3 中的 VO</i>AO 是同一个东西，负责管理所有的变量访问，LE 的提出是为了解决这样一个特定问题：with 下的 function expression 中的变量访问：</p>
<pre><code class='code-multiline'><span class="sf_code_syntax_project">var</span> x <span class="sf_code_syntax_keyword">=</span> <span class="sf_code_syntax_number">1</span>;
<span class="sf_code_syntax_project">function</span> <span class="sf_code_syntax_character">foo</span>() {
    <span class="sf_code_syntax_keyword">console</span>.log(x);
}
 
<span class="sf_code_syntax_keyword">with</span> ({<span class="sf_code_syntax_character">x</span>: <span class="sf_code_syntax_number">2</span>}) {
    <span class="sf_code_syntax_comment">// this is a function expression
</span>    <span class="sf_code_syntax_project">var</span> bar <span class="sf_code_syntax_keyword">=</span> <span class="sf_code_syntax_project">function</span> () {
        <span class="sf_code_syntax_keyword">console</span>.log(x);
    };
    foo(); <span class="sf_code_syntax_comment">// 1, from VariableEnvrionment
</span>    bar(); <span class="sf_code_syntax_comment">// 2, from LexicalEnvrionment
</span>}
foo(); <span class="sf_code_syntax_comment">// 1
</span>bar(); <span class="sf_code_syntax_comment">// still 2</span></code></pre>
<p><br></p>
<p>其实一般情况下，LE 只是 VE 的一个复制值，但是当出现例子这种情况的时候，必须在不破坏 VE 的情况下(因为 <code class='code-inline'>foo</code> 的调用需要用到 <code class='code-inline'>x = 1</code>)，同时提供另一套 <code class='code-inline'>{x: 2}</code> 会被先访问的 Environment(<code class='code-inline'>bar</code> 的调用要用到 <code class='code-inline'>x:2</code>)，于是会在进入 with block 的时候，保存好当前的 LE，同时改变 LE 为需要的 LE，在 with block 结束的时候恢复。</p>
<br>
<h3>Enviroment Record(ER)</h3>
<p>每一个 Environment 的结构会包含一个 ER 以及一个 outer，outer 其实就是上一层的 Environment，这点和 SC 很类似，不过是不完全一样的，下面的一个例子可以说明问题：</p>
<pre><code class='code-multiline'><span class="sf_code_syntax_project">var</span> x <span class="sf_code_syntax_keyword">=</span> <span class="sf_code_syntax_number">1</span>;
<span class="sf_code_syntax_project">function</span> <span class="sf_code_syntax_character">func</span>() {
    <span class="sf_code_syntax_project">var</span> y <span class="sf_code_syntax_keyword">=</span> <span class="sf_code_syntax_number">2</span>;
}

globalEnvironment <span class="sf_code_syntax_keyword">=</span> {
    <span class="sf_code_syntax_character">environmentRecord</span>: {
 
        <span class="sf_code_syntax_comment">// built-ins:
</span>        <span class="sf_code_syntax_keyword">Object</span>: function,
        <span class="sf_code_syntax_keyword">Array</span>: function,
        <span class="sf_code_syntax_comment">// etc ...
</span>    
        <span class="sf_code_syntax_comment">// our bindings:
</span>        <span class="sf_code_syntax_character">x</span>: <span class="sf_code_syntax_number">1</span>,
        <span class="sf_code_syntax_character">func</span>: function,

    },
 
    <span class="sf_code_syntax_character">outer</span>: <span class="sf_code_syntax_number">null</span> <span class="sf_code_syntax_comment">// no parent environment
</span> 
};
 
<span class="sf_code_syntax_comment">// environment of the "foo" function
</span> 
fooEnvironment <span class="sf_code_syntax_keyword">=</span> {
    <span class="sf_code_syntax_character">environmentRecord</span>: {
        <span class="sf_code_syntax_character">y</span>: <span class="sf_code_syntax_number">2</span>,
    },
    <span class="sf_code_syntax_character">outer</span>: globalEnvironment
};</code></pre>
<p><br></p>
<p>也许你有这样的疑惑，为什么需要做这样的改变呢？</p>
<p>答案是为了 Efficiency！</p>
<p>需要提到的是，规定(specification)并不提倡将 ER 实现为一个 simple object，这意味着各大 Engine 在这里可以提供自定义的优化！仔细想一想就会发现 SC 的设计会导致一层一层地查找某个变量，这个效率实在是太过低下，为什么不把会用到的变量放入当前 ER 中以提供直接的访问？此外还可以将不用到的变量不保存，这两点可以通过静态分析做到，V8 Engine 却是也是这样做的。</p>
<p>此外 environment record 有两种类型 decorative environment record(VER) 和 object environment record(OER)，两者的区别在于前者处理 function activation 以及 catch 时的 environment record(相当于以前的 AO)，后者用于处理 global context 下的 function、variable 以及 with 语句下的变量 binding，这只是规定(specification)上的区别，在实际实现中，并没有这个标志来指定 ER 的区别。</p>
<br>
<h2>原型编程</h2>
<h3>__proto__ 和 prototype 的区别</h3>
<p>在阐述原型之前，必须先澄清这两个概念的区别，其实说穿了也很简单，一个 object 的原型实际上就是 __proto__，那么 prototype 又是什么呢？</p>
<p>直接看如下一个例子：</p>
<br>
<pre><code class='code-multiline'><span class="sf_code_syntax_project">function</span> <span class="sf_code_syntax_character">Constructor</span>() {
    <span class="sf_code_syntax_keyword">this</span>.x <span class="sf_code_syntax_keyword">=</span> <span class="sf_code_syntax_number">3</span>;
}
<span class="sf_code_syntax_keyword">Constructor</span>.<span class="sf_code_syntax_keyword">prototype</span>. y <span class="sf_code_syntax_keyword">=</span> <span class="sf_code_syntax_number">4</span>;
<span class="sf_code_syntax_project">var</span> obj <span class="sf_code_syntax_keyword">=</span> <span class="sf_code_syntax_keyword">new</span> <span class="sf_code_syntax_keyword">Constructor</span>();
<span class="sf_code_syntax_keyword">console</span>.log(obj.__proto__ <span class="sf_code_syntax_keyword">===</span> <span class="sf_code_syntax_keyword">Constructor</span>.<span class="sf_code_syntax_keyword">prototype</span>) <span class="sf_code_syntax_comment">//true
</span><span class="sf_code_syntax_keyword">console</span>.log(obj.x, obj.y) <span class="sf_code_syntax_comment">//3, 4
</span></code></pre>看到这里你就知道了，当使用 <code class='code-inline'>new Cnostructor()</code> 来创建对象的话，那么 Constructor 的 prototype 便会是新创建对象的 __proto__。
值得注意的是，上面这个例子中，x 和 y 的查询是不同的，x 属于 obj 自己的属性，而 y 是属于其原型的属性。

因此一般说来，prototype 是 function 才有的属性，而所谓的原型编程实际上就是指使用 function 来进行 <u>_proto_</u> 的创建与传递。

另外，这里给出 Object 和 Function 的 <u>_proto_</u> 和 prototype:（注意 Object 和 Function 都是 function 类型的）

<pre><code class='code-multiline'>&gt; Function.__proto__
[Function]
&gt; Function.__proto__.__proto__
{}
&gt; Function.__proto__.__proto__.__proto__
null
&gt; Object.__proto__
[Function]
&gt; Object.__proto__.__proto__
{}
&gt; Object.__proto__.__proto__.__proto__
null
&gt; Function.prototype
[Function]
&gt; Object.prototype
{}</code></pre>
<p><br></p>
<h3>使用 prototype 来进行面向对象编程</h3>
<p>在 ES6 之前，并没有 class 的对象，但即使到了 ES6，所谓的 class 不过是 syntax sugar，本质其实还是 prototype 编程。</p>
<p>面向对象的三大特点：封装、继承、多态，下面依次阐述。</p>
<br>
<h4>封装</h4>
<p>这个现在即使在 ES6 也没有很好地解决办法，目前所知道的方法有两种</p>
<ol start="1"><li>ES7 中出现以 # 表示私有属性
</li><li>此外使用 ES6 的 Symbol 也可以达到模拟私有属性的效果
</li></ol>
<br>
<h4>继承</h4>
<p>这个在 ES6 之前的版本，其实是有方法进行继承模拟的，可以看下面的一个例子：</p>
<pre><code class='code-multiline'><span class="sf_code_syntax_project">function</span> <span class="sf_code_syntax_character">SupCls</span>() {
    <span class="sf_code_syntax_keyword">this</span>.x <span class="sf_code_syntax_keyword">=</span> <span class="sf_code_syntax_number">1</span>;
}
<span class="sf_code_syntax_keyword">SupCls</span>.<span class="sf_code_syntax_keyword">prototype</span>.y <span class="sf_code_syntax_keyword">=</span> <span class="sf_code_syntax_number">2</span>;
<span class="sf_code_syntax_project">var</span> supCls <span class="sf_code_syntax_keyword">=</span> <span class="sf_code_syntax_keyword">new</span> <span class="sf_code_syntax_keyword">SupCls</span>();
<span class="sf_code_syntax_keyword">console</span>.log(supCls.x, supCls.y);
<span class="sf_code_syntax_comment">// output: 1, 2
</span>
<span class="sf_code_syntax_comment">// now we will make an inheritance
</span><span class="sf_code_syntax_project">function</span> <span class="sf_code_syntax_character">SubCls</span>() {
    <span class="sf_code_syntax_keyword">this</span>.z <span class="sf_code_syntax_keyword">=</span> <span class="sf_code_syntax_number">3</span>;
}
<span class="sf_code_syntax_keyword">SubCls</span>.<span class="sf_code_syntax_keyword">prototype</span> <span class="sf_code_syntax_keyword">=</span> <span class="sf_code_syntax_keyword">new</span> <span class="sf_code_syntax_keyword">SupCls</span>();
<span class="sf_code_syntax_keyword">SubCls</span>.<span class="sf_code_syntax_keyword">prototype</span>.constructor <span class="sf_code_syntax_keyword">=</span> SubCls;
<span class="sf_code_syntax_project">var</span> subCls <span class="sf_code_syntax_keyword">=</span> <span class="sf_code_syntax_keyword">new</span> <span class="sf_code_syntax_keyword">SubCls</span>();
<span class="sf_code_syntax_keyword">console</span>.log(subCls.x, subCls.y, subCls.z);
<span class="sf_code_syntax_comment">// output: 1, 2, 3
</span><span class="sf_code_syntax_keyword">console</span>.log(subCls.__proto__);
<span class="sf_code_syntax_comment">// output: SubCls { x: 1, constructor: [Function: SubCls] }
</span><span class="sf_code_syntax_keyword">console</span>.log(subCls.hasOwnProperty(<span class="sf_code_syntax_string">'x'</span>));
<span class="sf_code_syntax_comment">// output: false</span></code></pre>
<p><br></p>
<p>这里解释一下最关键的一步，<code class='code-inline'>SubCls.prototype =  new SupCls()</code>，这可以使得新创建的 subCls 的 \_\_proto__ 是 SupCls 的 prototype，从而使得其具有父类的属性。</p>
<br>
<p>除此之外还有一个令人迷惑的地方就是，为什么需要做 <code class='code-inline'>SubCls.prototype.constructor = SubCls</code>？其实这步对于结果来说无关紧要，只是将 SubCls 的原型中的 constructor 指向正确的地方，如果没有这一步，上面的结果依然如此，也就是说 new 不会根据 prototype 的 constructor 来改变其行为，constructor 的存在只是给生成的 object 添加一个正确的引用。</p>
<br>
<p>其实这里有一个陷阱，那就是最后一条语句表明，x 不是 subCls 的instance属性！为什么会这样其实很好理解，因为 x 根据我们的做法是属于 SubCls 的 prototype 的属性，自然也是属于 subCls 的 \_\_proto__ 属性。</p>
<br>
<p>那么如何解决这个问题呢？</p>
<p>其实很简单，无非就是把 SupCls 中的 this 换成我们想要的，也就是 SubCls 中的 this，做一次 binding 就行了。</p>
<br>
<p>看下面的实现方式:</p>
<pre><code class='code-multiline'><span class="sf_code_syntax_project">function</span> <span class="sf_code_syntax_character">SupCls</span>() {
    <span class="sf_code_syntax_keyword">this</span>.x <span class="sf_code_syntax_keyword">=</span> <span class="sf_code_syntax_number">1</span>;
}
<span class="sf_code_syntax_keyword">SupCls</span>.<span class="sf_code_syntax_keyword">prototype</span>.y <span class="sf_code_syntax_keyword">=</span> <span class="sf_code_syntax_number">2</span>;
<span class="sf_code_syntax_project">var</span> supCls <span class="sf_code_syntax_keyword">=</span> <span class="sf_code_syntax_keyword">new</span> <span class="sf_code_syntax_keyword">SupCls</span>();
<span class="sf_code_syntax_keyword">console</span>.log(supCls.x, supCls.y);
<span class="sf_code_syntax_comment">// output: 1, 2
</span>
<span class="sf_code_syntax_comment">// now we will make an inheritance
</span><span class="sf_code_syntax_project">function</span> <span class="sf_code_syntax_character">SubCls</span>() {
    <span class="sf_code_syntax_keyword">this</span>.z <span class="sf_code_syntax_keyword">=</span> <span class="sf_code_syntax_number">3</span>;
    <span class="sf_code_syntax_comment">// binding is done here
</span>    SubCls.supertype.constructor.apply(<span class="sf_code_syntax_keyword">this</span>);
}
<span class="sf_code_syntax_keyword">SubCls</span>.<span class="sf_code_syntax_keyword">prototype</span> <span class="sf_code_syntax_keyword">=</span> <span class="sf_code_syntax_keyword">new</span> <span class="sf_code_syntax_keyword">SupCls</span>();
<span class="sf_code_syntax_keyword">SubCls</span>.<span class="sf_code_syntax_keyword">prototype</span>.constructor <span class="sf_code_syntax_keyword">=</span> SubCls;
SubCls.supertype <span class="sf_code_syntax_keyword">=</span> <span class="sf_code_syntax_keyword">SupCls</span>.<span class="sf_code_syntax_keyword">prototype</span>;
<span class="sf_code_syntax_project">var</span> subCls <span class="sf_code_syntax_keyword">=</span> <span class="sf_code_syntax_keyword">new</span> <span class="sf_code_syntax_keyword">SubCls</span>();
<span class="sf_code_syntax_keyword">console</span>.log(subCls.x, subCls.y, subCls.z);
<span class="sf_code_syntax_comment">// output: 1, 2, 3
</span><span class="sf_code_syntax_keyword">console</span>.log(subCls.__proto__);
<span class="sf_code_syntax_comment">// output: SubCls { x: 1, constructor: [Function: SubCls] }
</span><span class="sf_code_syntax_keyword">console</span>.log(subCls.hasOwnProperty(<span class="sf_code_syntax_string">'x'</span>));
<span class="sf_code_syntax_comment">// output: true</span></code></pre>
<p><br></p>
<p>也许你以为到这里就解决问题了，但实际上还有一个问题！</p>
<p>你可以发现，SupCls 这个 function 被调用了两次，而这个是可以避免的，为什么这么说？我们看这两次的调用时机：</p>
<ol start="1"><li><code class='code-inline'>SubCls.prototype = new SupCls();</code>
</li><li><code class='code-inline'>SubCls.supertype.constructor.apply(this);</code>
</li></ol>
<br>
<p>明显可以发现第一次的调用其实没有必要，因此第一次的调用我们只是想要拿到 SupCls 的 prototype 信息，而不是以它为 constructor 创建的 instance 信息，所以为了避免这个，我们可以这样来结束讨论：</p>
<pre><code class='code-multiline'><span class="sf_code_syntax_project">function</span> <span class="sf_code_syntax_character">SupCls</span>() {
    <span class="sf_code_syntax_keyword">this</span>.x <span class="sf_code_syntax_keyword">=</span> <span class="sf_code_syntax_number">1</span>;
}
<span class="sf_code_syntax_keyword">SupCls</span>.<span class="sf_code_syntax_keyword">prototype</span>.y <span class="sf_code_syntax_keyword">=</span> <span class="sf_code_syntax_number">2</span>;
<span class="sf_code_syntax_project">var</span> supCls <span class="sf_code_syntax_keyword">=</span> <span class="sf_code_syntax_keyword">new</span> <span class="sf_code_syntax_keyword">SupCls</span>();
<span class="sf_code_syntax_keyword">console</span>.log(supCls.x, supCls.y);
<span class="sf_code_syntax_comment">// output: 1, 2
</span>
<span class="sf_code_syntax_comment">// now we will make an inheritance
</span><span class="sf_code_syntax_project">function</span> <span class="sf_code_syntax_character">SubCls</span>() {
    <span class="sf_code_syntax_keyword">this</span>.z <span class="sf_code_syntax_keyword">=</span> <span class="sf_code_syntax_number">3</span>;
    <span class="sf_code_syntax_comment">// binding is done here
</span>    SubCls.supertype.constructor.apply(<span class="sf_code_syntax_keyword">this</span>);
}

<span class="sf_code_syntax_comment">// new part start
</span><span class="sf_code_syntax_project">function</span> <span class="sf_code_syntax_character">middleConstructor</span>() {}
<span class="sf_code_syntax_keyword">middleConstructor</span>.<span class="sf_code_syntax_keyword">prototype</span> <span class="sf_code_syntax_keyword">=</span> <span class="sf_code_syntax_keyword">SupCls</span>.<span class="sf_code_syntax_keyword">prototype</span>;
<span class="sf_code_syntax_keyword">SubCls</span>.<span class="sf_code_syntax_keyword">prototype</span> <span class="sf_code_syntax_keyword">=</span> <span class="sf_code_syntax_keyword">new</span> <span class="sf_code_syntax_keyword">middleConstructor</span>();
<span class="sf_code_syntax_comment">// new part end
</span>
<span class="sf_code_syntax_keyword">SubCls</span>.<span class="sf_code_syntax_keyword">prototype</span>.constructor <span class="sf_code_syntax_keyword">=</span> SubCls;
SubCls.supertype <span class="sf_code_syntax_keyword">=</span> <span class="sf_code_syntax_keyword">SupCls</span>.<span class="sf_code_syntax_keyword">prototype</span>;
<span class="sf_code_syntax_project">var</span> subCls <span class="sf_code_syntax_keyword">=</span> <span class="sf_code_syntax_keyword">new</span> <span class="sf_code_syntax_keyword">SubCls</span>();
<span class="sf_code_syntax_keyword">console</span>.log(subCls.x, subCls.y, subCls.z);
<span class="sf_code_syntax_comment">// output: 1, 2, 3
</span><span class="sf_code_syntax_keyword">console</span>.log(subCls.__proto__);
<span class="sf_code_syntax_comment">// output: SubCls { x: 1, constructor: [Function: SubCls] }
</span><span class="sf_code_syntax_keyword">console</span>.log(subCls.hasOwnProperty(<span class="sf_code_syntax_string">'x'</span>));
<span class="sf_code_syntax_comment">// output: true</span></code></pre>
<p><br></p>
<p>也许有人会有这样的疑惑，为什么不直接将 SupCls 的 prototype 赋给 SubCls 的 prototype，对此，我表示你自己一试，想一下就知道了原因了。</p>
<br>
<p>根据 Dmitry Soshnikov 的说法，ES6 class 的继承就是通过这样的方法实现的，不过我认为应该还是有出入的，这个还需要仔细探究一下。</p>
        </div>
        <script type="text/javascript">
            (function() {

    var doc_ols = document.getElementsByTagName("ol");

    for ( i=0; i<doc_ols.length; i++) {

        var ol_start = doc_ols[i].getAttribute("start") - 1;
        doc_ols[i].setAttribute("style", "counter-reset:ol " + ol_start + ";");

    }

})();
        </script>
        <style>
            html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td,article,aside,canvas,details,embed,figure,figcaption,footer,header,hgroup,menu,nav,output,ruby,section,summary,time,mark,audio,video{margin:0;padding:0;border:0;font:inherit;font-size:100%;vertical-align:baseline}html{line-height:1}ol,ul{list-style:none}table{border-collapse:collapse;border-spacing:0}caption,th,td{text-align:left;font-weight:normal;vertical-align:middle}q,blockquote{quotes:none}q:before,q:after,blockquote:before,blockquote:after{content:"";content:none}a img{border:none}article,aside,details,figcaption,figure,footer,header,hgroup,main,menu,nav,section,summary{display:block}*{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}html{font-size:87.5%;line-height:1.57143em}html{font-size:14px;line-height:1.6em;-webkit-text-size-adjust:100%}body{background:#fcfcfc;color:#545454;text-rendering:optimizeLegibility;font-family:"AvenirNext-Regular"}a{color:#de4c4f;text-decoration:none}h1{font-family:"AvenirNext-Medium";color:#333;font-size:1.6em;line-height:1.3em;margin-bottom:.78571em}h2{font-family:"AvenirNext-Medium";color:#333;font-size:1.3em;line-height:1em;margin-bottom:.62857em}h3{font-family:"AvenirNext-Medium";color:#333;font-size:1.15em;line-height:1em;margin-bottom:.47143em}p{margin-bottom:1.57143em;hyphens:auto}hr{height:1px;border:0;background-color:#dedede;margin:-1px auto 1.57143em auto}ul,ol{margin-bottom:.31429em}ul ul,ul ol,ol ul,ol ol{margin-bottom:0px}ol li:before{content:counter(ol) ".";counter-increment:ol;color:#e06e73;text-align:right;display:inline-block;min-width:1em;margin-right:0.5em}b,strong{font-family:"AvenirNext-Bold"}i,em{font-family:"AvenirNext-Italic"}code{font-family:"Menlo-Regular"}.text-overflow-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.sf_code_syntax_string{color:#D33905}.sf_code_syntax_comment{color:#838383}.sf_code_syntax_documentation_comment{color:#128901}.sf_code_syntax_number{color:#0E73A2}.sf_code_syntax_project{color:#5B2599}.sf_code_syntax_keyword{color:#0E73A2}.sf_code_syntax_character{color:#1B00CE}.sf_code_syntax_preprocessor{color:#920448}.note-wrapper{max-width:46em;margin:0px auto;padding:1.57143em 3.14286em}.note-wrapper.spotlight-preview{overflow-x:hidden}u{text-decoration:none;background-image:linear-gradient(to bottom, rgba(0,0,0,0) 50%,#e06e73 50%);background-repeat:repeat-x;background-size:2px 2px;background-position:0 1.05em}s{color:#878787}p{margin-bottom:0.1em}hr{margin-bottom:0.7em;margin-top:0.7em}ul li{text-indent:-0.35em}ul li:before{content:"•";color:#e06e73;display:inline-block;margin-right:0.3em}ul ul{margin-left:1.25714em}ol li{text-indent:-1.45em}ol ol{margin-left:1.25714em}blockquote{display:block;margin-left:-1em;padding-left:0.8em;border-left:0.2em solid #e06e73}.todo-list ul{margin-left:1.88571em}.todo-list li{text-indent:-1.75em}.todo-list li:before{content:"";display:static;margin-right:0px}.todo-checkbox{text-indent:-1.7em}.todo-checkbox svg{margin-right:0.3em;position:relative;top:0.2em}.todo-checkbox svg #check{display:none}.todo-checkbox.todo-checked #check{display:inline}.todo-checkbox.todo-checked .todo-text{text-decoration:line-through;color:#878787}.code-inline{display:inline;background:white;border:solid 1px #dedede;padding:0.2em 0.5em;font-size:0.9em}.code-multiline{display:block;background:white;border:solid 1px #dedede;padding:0.7em 1em;font-size:0.9em;overflow-x:auto}.hashtag{display:inline-block;color:white;background:#b8bfc2;padding:0.0em 0.5em;border-radius:1em;text-indent:0}.hashtag a{color:#fff}.address a{color:#545454;background-image:linear-gradient(to bottom, rgba(0,0,0,0) 50%,#0da35e 50%);background-repeat:repeat-x;background-size:2px 2px;background-position:0 1.05em}.address svg{position:relative;top:0.2em;display:inline-block;margin-right:0.2em}.color-preview{display:inline-block;width:1em;height:1em;border:solid 1px rgba(0,0,0,0.3);border-radius:50%;margin-right:0.1em;position:relative;top:0.2em;white-space:nowrap}.color-code{margin-right:0.2em;font-family:"Menlo-Regular";font-size:0.9em}.color-hash{opacity:0.4}.ordered-list-number{color:#e06e73;text-align:right;display:inline-block;min-width:1em}.arrow svg{position:relative;top:0.08em;display:inline-block;margin-right:0.15em;margin-left:0.15em}.arrow svg #rod{stroke:#545454}.arrow svg #point{fill:#545454}mark{color:inherit;display:inline-block;padding:0px 4px;background-color:#fcffc0}img{max-width:100%;height:auto}

        </style>
    </body>
</html>
