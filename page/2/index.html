<!DOCTYPE html>
<html lang="">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />









  <link rel="alternate" href="/atom.xml" title="ShiKaiWi's Homepage">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.2.x" />



<link rel="canonical" href="https://ShiKaiWi.github.io/page/2/"/>


<meta property="og:type" content="website">
<meta property="og:title" content="ShiKaiWi's Homepage">
<meta property="og:url" content="https://ShiKaiWi.github.io/page/2/index.html">
<meta property="og:site_name" content="ShiKaiWi's Homepage">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ShiKaiWi's Homepage">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.2.x" />



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />





<script type="text/javascript">
  var themeConfig = {
    search: {
      enable: true,
      path: "/search.xml",
    },
    navbar: {
      enable: true
    },
    fancybox: {
      enable: true
    },
    toc: {
      enable: true
    },
  };
</script>



  



    <title> ShiKaiWi's Homepage </title>
  </head>

  <body>
    <div class="container">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">ShiKaiWi's Homepage</a>
</div>

<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              Home
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              Archives
            
          </a>
        </li>
      
      
        <li class="menu-search">
          <form>
            <i class="iconfont icon-search" id="open-search"></i>
            <input type="text" class="search-input" id="search-input" />
            <i class="iconfont icon-close" id="close-search"></i>
          </form>
        </li>
      
    </ul>
  
</nav>

<div class="mobile-navbar">
  <div class="mobile-header">
    <div class="mobile-header-logo">
      <a href="/." class="logo">ShiKaiWi's Homepage</a>
    </div>

    <div class="mobile-header-icon">
      <span></span>
      <span></span>
      <span></span>
    </div>
  </div>
  <nav class="mobile-menu">
    
      <a class="mobile-menu-item" href="/">
        
        
          Home
        
      </a>
    
      <a class="mobile-menu-item" href="/archives/">
        
        
          Archives
        
      </a>
    
  </nav>
</div>
      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  <section id="posts" class="posts">
    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/02/17/JavaScript-ES5-总结/">JavaScript ES5 总结</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Feb 17, 2017
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>JavaScript 的语法让我感到非常不舒服，究其原因其实是因为两点：</p>
<ol>
<li>动态语言</li>
<li>原型编程</li>
</ol>
<p>对于动态语言，我个人始终认为是不符合大型 project 的要求的，因为动态语言的特性导致阅读代码的时候非常不顺利，比如你看到一个 function 的参数时候，你完全不知道它是怎样的结构，但是像 Java 这样的强类型语言，每一个参数都有类型，就使得对于每一个参数你都知道它实实在在的含义（可以去查看参数类型的定义）。<br>此外原型编程，我迄今看不出其优势所在，不仅每一个对象的原型都可以被随意改变，而且根本没有访问控制。</p>
<p>但尽管如此，我个人认为 JavaScript 还是更加现代化的编程语言，比如它的 function 可以作为对象任意传递，这一点和 Python 类似，对于异步编程可以说是非常直观地支持。<br>然而 JavaScript 的发展在 2015 年 ES6 发布后，就迎来了非常大的增强，我想为了更好的学习 ES6，对之前版本的深层次的理解还是需要的，相当于打好基础才能更好地前进。<br>在本篇 post 中，我主要是对自己看过的 Dmitry Soshnikov 的一系列关于 ES3-ES5 的 <a href="http://dmitrysoshnikov.com" target="_blank" rel="external">posts</a> 总结，主要包含 JavaScript 中最迷惑人的两个部分：</p>
<ol>
<li>变量管理</li>
<li>原型编程</li>
</ol>
<h2 id="变量管理"><a href="#变量管理" class="headerlink" title="变量管理"></a>变量管理</h2><p>这里使用的变量管理并不是指硬件层面的实现，而是指 JavaScript 的变量存储的抽象模型。另外，在概念上，ES3 和 ES5 有着几个区别，因此会分别描述。</p>
<h3 id="ES3"><a href="#ES3" class="headerlink" title="ES3"></a>ES3</h3><h4 id="Execution-Context-EC"><a href="#Execution-Context-EC" class="headerlink" title="Execution Context(EC)"></a>Execution Context(EC)</h4><p>在 JavaScript 中有两种 EC：global context 和 function context。<br>不同的 context 的管理是用 stack 模式管理的，举个例子，在 global context 下定义了一个 function func，那么整个 EC stack 就是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">EC Stack = &#123;</div><div class="line">    funcContext,</div><div class="line">    globalContext,</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果从 funcContext 退出那么，EC Stack 将会只剩下 globalContext，符合 Stack 的管理方式。<br>EC 有着许多重要的 property，用以在运行时使用，而在本篇 post 中，着重强调变量管理这一个问题，因此会探究其相关属性。</p>
<h4 id="Variable-Object-VO-Activation-Object-AO"><a href="#Variable-Object-VO-Activation-Object-AO" class="headerlink" title="Variable Object(VO) / Activation Object(AO)"></a>Variable Object(VO) / Activation Object(AO)</h4><p>VO 和 AO 其实类似于符号表(symbol table)，用以集中管理变量，并且这是 EC 的属性，在 ES6 之前是没有 var 之外的变量定义方式的(有隐式定义变量，下面会提到)，而对 var 的处理会在<strong>静态分析</strong>进行，并且将定义的变量名填入 VO/AO，但是并不会直接对其赋值，而是等到执行到赋值语句的时候才会：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// now VO = &#123;</span></div><div class="line"><span class="comment">//     a: undefined,</span></div><div class="line"><span class="comment">// &#125;</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></div><div class="line"><span class="keyword">var</span> a = <span class="number">13</span>;</div><div class="line"></div><div class="line"><span class="comment">// now VO = &#123;</span></div><div class="line"><span class="comment">//     a: 13,</span></div><div class="line"><span class="comment">// &#125;</span></div></pre></td></tr></table></figure></p>
<p>这里既然都是符号表，为什么有 VO 和 AO 的区别呢？<br>VO 其实是指 global context 的符号表，而 AO 是指 function context 的符号表，之所以有这两者的区别是因为 function context 有着不一样的符号管理，总共包括三类符号：</p>
<ol>
<li>arguments：即 function 的参数</li>
<li>functions：function 内部定义的 function，在静态分析期间，如果符号与 arguments、variables 中的有冲突，直接替代(function 提升)</li>
<li>variables：function 内部定义的变量，如果和 1、2 有冲突，在静态分析期间不会造成影响，在执行期间会直接替代 1 中的冲突项(理所当然的，后来覆盖)，与 2 的互相替代也符合后来覆盖原则</li>
</ol>
<p>直接看一个例子就知道区别了：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">f</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(f);</div><div class="line">    <span class="keyword">var</span> f = <span class="number">4</span>;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">    <span class="built_in">console</span>.log(f);</div><div class="line">&#125;</div><div class="line">func(<span class="number">3</span>);</div><div class="line"><span class="comment">// output:</span></div><div class="line"><span class="comment">// [Function: f]</span></div><div class="line"><span class="comment">// 4</span></div></pre></td></tr></table></figure></p>
<p>这段的最后还要说明一下隐式声明的问题，上面提到如果直接给一个变量赋值(不用 var)也是可以的，但是其实不是向 VO 中添加符号，而是给当前的 EC 下的 this 变量添加了一个属性而已。<br>看下面的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">x = <span class="number">3</span>;</div><div class="line"><span class="keyword">var</span> a = <span class="number">4</span>;</div><div class="line"><span class="keyword">delete</span> a;</div><div class="line"><span class="keyword">delete</span> x;</div><div class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 4</span></div><div class="line"><span class="built_in">console</span>.log(x); <span class="comment">// Reference Error</span></div></pre></td></tr></table></figure></p>
<h3 id="Scope-Chain-SC"><a href="#Scope-Chain-SC" class="headerlink" title="Scope Chain(SC)"></a>Scope Chain(SC)</h3><p>按道理说有了 EC 和 VO，那么便可以在任何一个特定的 EC 下进行变量访问，但是如果出现当前变量无法再当前 EC 下找到，那么该如何处理呢？为了解决这种情况，SC 被引入自然是很正常的事情，而 SC 和其他语言的构造方法基本一致：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SC(ECStack[top]) = VO/AO + SC(ECStack[top<span class="number">-1</span>]);</div><div class="line">ECStack[<span class="number">0</span>] === globalContext;</div></pre></td></tr></table></figure></p>
<p>但需要注意的是，JavaScript 并没有 block 的概念，这是和其他主流语言的最大区别之一，也正因为如此只有 function 才能创造新的 context，因此常常会说一个 function 的 SC，但实际上是 EC 的 SC。因此对于 function 中的变量解析，自然是很重要的，但其实也很简单，只需要注意一点 <strong>function 的 SC 是静态分析确立的</strong>，会在运行前把需要用的变量的 Reference 记录下来：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">3</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(x);</div><div class="line">&#125;</div><div class="line">func(); <span class="comment">// output: 3</span></div><div class="line">x = <span class="number">4</span>;</div><div class="line">func(); <span class="comment">// output: 4</span></div></pre></td></tr></table></figure></p>
<p>此外，with 和 catch 会把其引入的变量加入到当前 SC 的最前面:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> obj  = &#123;</div><div class="line">        <span class="attr">x</span>: <span class="number">3</span>,</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> x = <span class="number">4</span>;</div><div class="line">    <span class="keyword">with</span>(obj)&#123;</div><div class="line">        <span class="built_in">console</span>.log(x);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">func();<span class="comment">// output: 3</span></div></pre></td></tr></table></figure></p>
<p>还有一点比较重要的是，因为 JavaScript 的有着 prototype，因此当顺着 SC 找到最后，可以访问到 Object 的 prototype 上去，可以看下面这个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(x);</div><div class="line">&#125;</div><div class="line"><span class="built_in">Object</span>.prototype.x = <span class="number">10</span>;</div><div class="line">foo(); <span class="comment">// 10</span></div></pre></td></tr></table></figure></p>
<h4 id="属性访问"><a href="#属性访问" class="headerlink" title="属性访问"></a>属性访问</h4><p>讲到这里，有了 EC、VO、SC，我们看似便可以对几乎所有的变量进行访问了，但是还有一种情况没有考虑，那就是 object 的属性访问，而在属性访问中，还有一个特别的例子，就是 this 的属性访问。</p>
<h5 id="Reference-Type-RT"><a href="#Reference-Type-RT" class="headerlink" title="Reference Type(RT)"></a>Reference Type(RT)</h5><p>属性访问问题解决的本质其实在于如何定义这样的访问方法，而 JS 的做法是通过 RT 来解决，RT 的产生只在两者情况下：</p>
<ol>
<li>处理变量名(identifier)[这里表明，普通变量的访问其实也是通过 RT 来解决的]</li>
<li>处理属性访问符(property accessor)</li>
</ol>
<p>而 RT 的基本结构如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="number">3</span>;</div><div class="line"><span class="comment">// fooReferenceType = &#123;</span></div><div class="line"><span class="comment">//    base: null,  =&gt; null will be transformed to globalContext's VO</span></div><div class="line"><span class="comment">//    propertyName: foo,</span></div><div class="line"><span class="comment">//&#125;</span></div></pre></td></tr></table></figure>
<p>当引用 foo 变量的时候，首先便会得到一个 fooReferenceType，然后每一个 RT 都有一个获取属性值的方法(GetValue)，这样就解决了属性访问的问题(其实说到可以发现，JS 里所有的变量访问都是属性访问，只不过没有指定 object 的地方基本上使用的 SC 上一层 VO/AO)。</p>
<h5 id="this-绑定"><a href="#this-绑定" class="headerlink" title="this 绑定"></a>this 绑定</h5><p>this 的使用一般是如下情况：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">x</span>:<span class="number">1</span>&#125;;</div><div class="line">obj.func();</div></pre></td></tr></table></figure>
<p>这里在 func 的内部如何知道 this 这个 object 是什么呢？这里就涉及到了 this 的 binding 问题。<br>其实 this 的绑定规则很简单，可以这么说 <strong>this 的绑定完全由 function 的调用方式决定</strong>，这是因为 this 绑定的 object 就是 <strong>function 前面的变量的 RT 的 base</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj1 = &#123;</div><div class="line">    <span class="attr">x</span>: <span class="number">1</span>,</div><div class="line">    <span class="attr">func</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</div><div class="line">        &#125;,</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> obj2 = &#123;</div><div class="line">    <span class="attr">x</span>: <span class="number">2</span>,</div><div class="line">    <span class="attr">func</span>: <span class="literal">undefined</span>,</div><div class="line">&#125;;</div><div class="line">obj1.func(); <span class="comment">// output 1</span></div><div class="line">obj2.func = obj1.func;</div><div class="line">obj2.func(); <span class="comment">// output 2</span></div><div class="line">(obj2.func = obj1.func)(); <span class="comment">// output undefined</span></div></pre></td></tr></table></figure>
<p>这是一个很经典的例子，1 和 2 的输出根据上面的理论是理所当然的结果，但是最后一个 undefined 的结果可能就有点令人费解了。它背后的机制是这样的，<code>(obj2.func = obj1.func)</code> 括号内一个表达式，并不是一个变量名(identifier)，当然也不是属性访问器(property accessor)，因此对它解析不会产生 RT，也因此其 this 的绑定为 null，而 null 作为 this 的值在 non-strict 模式下是会被转化成 globalContext 的 VO 的。</p>
<h2 id="ES5"><a href="#ES5" class="headerlink" title="ES5"></a>ES5</h2><h3 id="Call-Stack"><a href="#Call-Stack" class="headerlink" title="Call Stack"></a>Call Stack</h3><p>将 EC 的称谓正式变为 Call Stack，本质并没有太多变化。</p>
<h3 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h3><p>ES5 管理变量的方式发生了比较大的变化，首先不在使用 VO 和 AO 了，统一成了 Environment，但是 Environment 分为两类，Variable Environment(VE) 和 Lexical Environment(LE) 两种，但是和 VO/AO 的分类并没有直接关系，其实 VE 本质上和 ES3 中的 VO/AO 是同一个东西，负责管理所有的变量访问，LE 的提出是为了解决这样一个特定问题：<strong>with 下的 function expression 中的变量访问</strong>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(x);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">with</span> (&#123;<span class="attr">x</span>: <span class="number">2</span>&#125;) &#123;</div><div class="line">    <span class="comment">// this is a function expression</span></div><div class="line">    <span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(x);</div><div class="line">    &#125;;</div><div class="line">    foo(); <span class="comment">// 1, from VariableEnvrionment</span></div><div class="line">    bar(); <span class="comment">// 2, from LexicalEnvrionment</span></div><div class="line">&#125;</div><div class="line">foo(); <span class="comment">// 1</span></div><div class="line">bar(); <span class="comment">// still 2</span></div></pre></td></tr></table></figure></p>
<p>其实一般情况下，LE 只是 VE 的一个复制值，但是当出现例子这种情况的时候，必须在不破坏 VE 的情况下(因为 <code>foo</code> 的调用需要用到 <code>x = 1</code>)，同时提供另一套 <code>{x: 2}</code> 会被先访问的 Environment(<code>bar</code> 的调用要用到 <code>x:2</code>)，于是会在进入 with block 的时候，保存好当前的 LE，同时改变 LE 为需要的 LE，在 with block 结束的时候恢复。</p>
<h3 id="Enviroment-Record-ER"><a href="#Enviroment-Record-ER" class="headerlink" title="Enviroment Record(ER)"></a>Enviroment Record(ER)</h3><p>每一个 Environment 的结构会包含一个 ER 以及一个 outer，outer 其实就是上一层的 Environment，这点和 SC 很类似，不过是不完全一样的，下面的一个例子可以说明问题：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> y = <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">globalEnvironment = &#123;</div><div class="line">    <span class="attr">environmentRecord</span>: &#123;</div><div class="line"> </div><div class="line">        <span class="comment">// built-ins:</span></div><div class="line">        <span class="built_in">Object</span>: <span class="function"><span class="keyword">function</span>,</span></div><div class="line">        <span class="title">Array</span>: <span class="title">function</span>,</div><div class="line">        // <span class="title">etc</span> ...</div><div class="line">    </div><div class="line">        // <span class="title">our</span> <span class="title">bindings</span>:</div><div class="line">        <span class="title">x</span>: 1,</div><div class="line">        <span class="title">func</span>: <span class="title">function</span>,</div><div class="line"></div><div class="line">    &#125;,</div><div class="line"> </div><div class="line">    <span class="title">outer</span>: <span class="title">null</span> // <span class="title">no</span> <span class="title">parent</span> <span class="title">environment</span></div><div class="line"> </div><div class="line">&#125;;</div><div class="line"> </div><div class="line">// <span class="title">environment</span> <span class="title">of</span> <span class="title">the</span> "<span class="title">foo</span>" <span class="title">function</span></div><div class="line"> </div><div class="line"><span class="title">fooEnvironment</span> = &#123;</div><div class="line">    environmentRecord: &#123;</div><div class="line">        <span class="attr">y</span>: <span class="number">2</span>,</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">outer</span>: globalEnvironment</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>也许你有这样的疑惑，为什么需要做这样的改变呢？<br>答案是为了 Efficiency！<br>需要提到的是，规定(specification)并不提倡将 ER 实现为一个 simple object，这意味着各大 Engine 在这里可以提供自定义的优化！仔细想一想就会发现 SC 的设计会导致一层一层地查找某个变量，这个效率实在是太过低下，为什么不把会用到的变量放入当前 ER 中以提供直接的访问？此外还可以将不用到的变量不保存，这两点可以通过静态分析做到，V8 Engine 却是也是这样做的。<br>此外 environment record 有两种类型 decorative environment record(VER) 和 object environment record(OER)，两者的区别在于前者处理 function activition 以及 catch 时的 environment record(相当于以前的 AO)，后者用于处理 global context 下的 function、variable 以及 with 语句下的变量 binding，这只是规定(specification)上的区别，在实际实现中，并没有这个标志来指定 ER 的区别。</p>
<h2 id="原型编程"><a href="#原型编程" class="headerlink" title="原型编程"></a>原型编程</h2><h3 id="proto-和-prototype-的区别"><a href="#proto-和-prototype-的区别" class="headerlink" title="__proto__ 和 prototype 的区别"></a>__proto__ 和 prototype 的区别</h3><p>在阐述原型之前，必须先澄清这两个概念的区别，其实说穿了也很简单，一个 object 的原型实际上就是 __proto__，那么 prototype 又是什么呢？<br>直接看如下一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Constructor</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.x = <span class="number">3</span>;</div><div class="line">&#125;</div><div class="line">Constructor.prototype. y = <span class="number">4</span>;</div><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Constructor();</div><div class="line"><span class="built_in">console</span>.log(obj.__proto__ === Constructor.prototype) <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(obj.x, obj.y) <span class="comment">//3, 4</span></div></pre></td></tr></table></figure>
<p>看到这里你就知道了，当使用 <code>new Cnostructor()</code> 来创建对象的话，那么 Constructor 的 prototype 便会是新创建对象的 __proto__。<br>值得注意的是，上面这个例子中，x 和 y 的查询是不同的，x 属于 obj 自己的属性，而 y 是属于其原型的属性。</p>
<p>因此一般说来，prototype 是 function 才有的属性，而所谓的原型编程实际上就是指使用 function 来进行 __proto__ 的创建与传递。</p>
<p>另外，这里给出 Object 和 Function 的 __proto__ 和 prototype:（注意 Object 和 Funtion 都是 function 类型的）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&gt; Function.__proto__</div><div class="line">[Function]</div><div class="line">&gt; Function.__proto__.__proto__</div><div class="line">&#123;&#125;</div><div class="line">&gt; Function.__proto__.__proto__.__proto__</div><div class="line">null</div><div class="line">&gt; Object.__proto__</div><div class="line">[Function]</div><div class="line">&gt; Object.__proto__.__proto__</div><div class="line">&#123;&#125;</div><div class="line">&gt; Object.__proto__.__proto__.__proto__</div><div class="line">null</div><div class="line">&gt; Function.prototype</div><div class="line">[Function]</div><div class="line">&gt; Object.prototype</div><div class="line">&#123;&#125;</div></pre></td></tr></table></figure>
<h3 id="使用-prototype-来进行面向对象编程"><a href="#使用-prototype-来进行面向对象编程" class="headerlink" title="使用 prototype 来进行面向对象编程"></a>使用 prototype 来进行面向对象编程</h3><p>在 ES6 之前，并没有 class 的对象，但即使到了 ES6，所谓的 class 不过是 syntax sugar，本质其实还是 prototype 编程。<br>面向对象的三大特点：封装、继承、多态，下面依次阐述。</p>
<h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>这个现在即使在 ES6 也没有很好地解决办法，目前所知道的方法有两种</p>
<ol>
<li>ES7 中出现以 # 表示私有属性</li>
<li>此外使用 ES6 的 Symbol 也可以达到模拟私有属性的效果</li>
</ol>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>这个在 ES6 之前的版本，其实是有方法进行继承模拟的，可以看下面的一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SupCls</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.x = <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line">SupCls.prototype.y = <span class="number">2</span>;</div><div class="line"><span class="keyword">var</span> supCls = <span class="keyword">new</span> SupCls();</div><div class="line"><span class="built_in">console</span>.log(supCls.x, supCls.y);</div><div class="line"><span class="comment">// output: 1, 2</span></div><div class="line"></div><div class="line"><span class="comment">// now we will make an inheritance</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubCls</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.z = <span class="number">3</span>;</div><div class="line">&#125;</div><div class="line">SubCls.prototype = <span class="keyword">new</span> SupCls();</div><div class="line">SubCls.prototype.constructor = SubCls;</div><div class="line"><span class="keyword">var</span> subCls = <span class="keyword">new</span> SubCls();</div><div class="line"><span class="built_in">console</span>.log(subCls.x, subCls.y, subCls.z);</div><div class="line"><span class="comment">// output: 1, 2, 3</span></div><div class="line"><span class="built_in">console</span>.log(subCls.__proto__);</div><div class="line"><span class="comment">// output: SubCls &#123; x: 1, constructor: [Function: SubCls] &#125;</span></div><div class="line"><span class="built_in">console</span>.log(subCls.hasOwnProperty(<span class="string">'x'</span>));</div><div class="line"><span class="comment">// output: false</span></div></pre></td></tr></table></figure>
<p>这里解释一下最关键的一步，<code>SubCls.prototype =  new SupCls()</code>，这可以使得新创建的 subCls 的 __proto__ 是 SupCls 的 prototype，从而使得其具有父类的属性。</p>
<p>除此之外还有一个令人迷惑的地方就是，为什么需要做 <code>SubCls.prototype.constructor = SubCls</code>？其实这步对于结果来说无关紧要，只是将 SubCls 的原型中的 constructor 指向正确的地方，如果没有这一步，上面的结果依然如此，也就是说 new 不会根据 prototype 的 constructor 来改变其行为，constructor 的存在只是给生成的 object 添加一个正确的引用。</p>
<p>其实这里有一个陷阱，那就是最后一条语句表明，x 不是 subCls 的instance属性！为什么会这样其实很好理解，因为 x 根据我们的做法是属于 SubCls 的 prototype 的属性，自然也是属于 subCls 的 __proto__ 属性。</p>
<p>那么如何解决这个问题呢？<br>其实很简单，无非就是把 SupCls 中的 this 换成我们想要的，也就是 SubCls 中的 this，做一次 binding 就行了。</p>
<p>看下面的实现方式:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SupCls</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.x = <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line">SupCls.prototype.y = <span class="number">2</span>;</div><div class="line"><span class="keyword">var</span> supCls = <span class="keyword">new</span> SupCls();</div><div class="line"><span class="built_in">console</span>.log(supCls.x, supCls.y);</div><div class="line"><span class="comment">// output: 1, 2</span></div><div class="line"></div><div class="line"><span class="comment">// now we will make an inheritance</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubCls</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.z = <span class="number">3</span>;</div><div class="line">    <span class="comment">// binding is done here</span></div><div class="line">    SubCls.supertype.constructor.apply(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line">SubCls.prototype = <span class="keyword">new</span> SupCls();</div><div class="line">SubCls.prototype.constructor = SubCls;</div><div class="line">SubCls.supertype = SupCls.prototype;</div><div class="line"><span class="keyword">var</span> subCls = <span class="keyword">new</span> SubCls();</div><div class="line"><span class="built_in">console</span>.log(subCls.x, subCls.y, subCls.z);</div><div class="line"><span class="comment">// output: 1, 2, 3</span></div><div class="line"><span class="built_in">console</span>.log(subCls.__proto__);</div><div class="line"><span class="comment">// output: SubCls &#123; x: 1, constructor: [Function: SubCls] &#125;</span></div><div class="line"><span class="built_in">console</span>.log(subCls.hasOwnProperty(<span class="string">'x'</span>));</div><div class="line"><span class="comment">// output: true</span></div></pre></td></tr></table></figure>
<p>也许你以为到这里就解决问题了，但实际上还有一个问题！<br>你可以发现，SupCls 这个 function 被调用了两次，而这个是可以避免的，为什么这么说？我们看这两次的调用时机：</p>
<ol>
<li><code>SubCls.prototype = new SupCls();</code></li>
<li><code>SubCls.supertype.constructor.apply(this);</code></li>
</ol>
<p>明显可以发现第一次的调用其实没有必要，因此第一次的调用我们只是想要拿到 SupCls 的 prototype 信息，而不是以它为 constructor 创建的 instance 信息，所以为了避免这个，我们可以这样来结束讨论：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SupCls</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.x = <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line">SupCls.prototype.y = <span class="number">2</span>;</div><div class="line"><span class="keyword">var</span> supCls = <span class="keyword">new</span> SupCls();</div><div class="line"><span class="built_in">console</span>.log(supCls.x, supCls.y);</div><div class="line"><span class="comment">// output: 1, 2</span></div><div class="line"></div><div class="line"><span class="comment">// now we will make an inheritance</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubCls</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.z = <span class="number">3</span>;</div><div class="line">    <span class="comment">// binding is done here</span></div><div class="line">    SubCls.supertype.constructor.apply(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// new part start</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">middleConstructor</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">middleConstructor.prototype = SupCls.prototype;</div><div class="line">SubCls.prototype = <span class="keyword">new</span> middleConstructor();</div><div class="line"><span class="comment">// new part end</span></div><div class="line"></div><div class="line">SubCls.prototype.constructor = SubCls;</div><div class="line">SubCls.supertype = SupCls.prototype;</div><div class="line"><span class="keyword">var</span> subCls = <span class="keyword">new</span> SubCls();</div><div class="line"><span class="built_in">console</span>.log(subCls.x, subCls.y, subCls.z);</div><div class="line"><span class="comment">// output: 1, 2, 3</span></div><div class="line"><span class="built_in">console</span>.log(subCls.__proto__);</div><div class="line"><span class="comment">// output: SubCls &#123; x: 1, constructor: [Function: SubCls] &#125;</span></div><div class="line"><span class="built_in">console</span>.log(subCls.hasOwnProperty(<span class="string">'x'</span>));</div><div class="line"><span class="comment">// output: true</span></div></pre></td></tr></table></figure></p>
<p>也许有人会有这样的疑惑，为什么不直接将 SupCls 的 prototype 赋给 SubCls 的 prototype，对此，我表示你自己一试，想一下就知道了原因了。</p>
<p>根据 Dmitry Soshnikov 的说法，ES6 class 的继承就是通过这样的方法实现的，不过我认为应该还是有出入的，这个还需要仔细探究一下。</p>

        
      
    </div>

    

    
  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/02/14/Hexo_With_GitHub/">Deploy Hexo Blogs on GitHub Pages</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Feb 14, 2017
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h3 id="Create-a-GitHub-Page"><a href="#Create-a-GitHub-Page" class="headerlink" title="Create a GitHub Page"></a>Create a GitHub Page</h3><p>Follow the steps on this <a href="https://pages.github.com/" target="_blank" rel="external">page</a> to create a personal website, say <code>https://username.github.io</code>.</p>
<h3 id="Install-Hexo"><a href="#Install-Hexo" class="headerlink" title="Install Hexo"></a>Install Hexo</h3><p>After <code>git</code> and <code>nodejs</code> installed, get the Hexo installed by:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g hexo-cli</div></pre></td></tr></table></figure></p>
<p>Try to get what you are confused about from this <a href="https://hexo.io/docs/" target="_blank" rel="external">page</a>.</p>
<h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-https-username-github-io"><a href="#Deploy-to-https-username-github-io" class="headerlink" title="Deploy to https://username.github.io"></a>Deploy to <code>https://username.github.io</code></h3><p>Before the deploying, change the deploy settings:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># Deployment</div><div class="line">## Docs: https://hexo.io/docs/deployment.html</div><div class="line">deploy:</div><div class="line">  type: git</div><div class="line">  repository: git@github.com:username/username.github.io.git</div><div class="line">  branch: master</div></pre></td></tr></table></figure></p>
<p>After the setting, the git deploy helper should be installed by:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-deployer-git --save</div></pre></td></tr></table></figure></p>
<p>Deploying:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure></p>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

        
      
    </div>

    

    
  </article>

    
  </section>

  
  <nav class="pagination">
    
      <a class="prev" href="/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text">上一页</span>
      </a>
    
    
  </nav>


          </div>
          
        </div>  
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:xykwei@gmail.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
        
          <a href="https://github.com/ShiKaiWi" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
    
    
  </div>


<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
    
    2017

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">ShiKaiWi</span>
  </span>
</div>
      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    


    
  





  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  

    <script type="text/javascript" src="/js/src/even.js?v=2.2.x"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.2.x"></script>

  </body>
</html>