<!DOCTYPE html>
<html lang="">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />









  <link rel="alternate" href="/atom.xml" title="ShiKaiWi's Homepage">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.2.x" />



<link rel="canonical" href="https://ShiKaiWi.github.io/"/>


<meta property="og:type" content="website">
<meta property="og:title" content="ShiKaiWi's Homepage">
<meta property="og:url" content="https://ShiKaiWi.github.io/index.html">
<meta property="og:site_name" content="ShiKaiWi's Homepage">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ShiKaiWi's Homepage">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.2.x" />



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />





<script type="text/javascript">
  var themeConfig = {
    search: {
      enable: true,
      path: "/search.xml",
    },
    navbar: {
      enable: true
    },
    fancybox: {
      enable: true
    },
    toc: {
      enable: true
    },
  };
</script>



  



    <title> ShiKaiWi's Homepage </title>
  </head>

  <body>
    <div class="container">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">ShiKaiWi's Homepage</a>
</div>

<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              Home
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              Archives
            
          </a>
        </li>
      
      
        <li class="menu-search">
          <form>
            <i class="iconfont icon-search" id="open-search"></i>
            <input type="text" class="search-input" id="search-input" />
            <i class="iconfont icon-close" id="close-search"></i>
          </form>
        </li>
      
    </ul>
  
</nav>

<div class="mobile-navbar">
  <div class="mobile-header">
    <div class="mobile-header-logo">
      <a href="/." class="logo">ShiKaiWi's Homepage</a>
    </div>

    <div class="mobile-header-icon">
      <span></span>
      <span></span>
      <span></span>
    </div>
  </div>
  <nav class="mobile-menu">
    
      <a class="mobile-menu-item" href="/">
        
        
          Home
        
      </a>
    
      <a class="mobile-menu-item" href="/archives/">
        
        
          Archives
        
      </a>
    
  </nav>
</div>
      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  <section id="posts" class="posts">
    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/05/21/可读性好的代码/">可读性好的代码</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          May 21, 2017
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>我本周最大的收获便是读完了 “the art of readable code”, 这本书由 Dustin Boswell，Travor Foucher 合作完成，主要讲述一些利于提升代码可读性的总结性技巧，看完收获颇多，写下这边 post 来总结一下自己所学到的东西。</p>
<h1 id="Name"><a href="#Name" class="headerlink" title="Name"></a>Name</h1><p>1.命名要具体</p>
<p>最常见的例子便是 get* 的使用，比如从服务器端拉取数据，很喜欢使用 get，但实际上并不是向 get 描述的那样，很简单就拉取到了，这里使用 fetch 是更好的选择。</p>
<p>2.避免使用没意义的名字</p>
<p>如 ret、result、tmp，除非这个变量只会出现在三行左右的地方</p>
<p>3.添加更多信息到命名之中</p>
<p>比如 size，size 时大小的含义，但是如果有单位区分的话，那么一个 size 很容易造成误解，可以加上 size_KB/size_kb</p>
<p>4.属性、方法的命名传统（工作的时候遇到的）</p>
<p>属性的话，一般是 名词／形容词<br>方法的命名一般是 动词词组</p>
<p>5.避免使用含义不清晰的词</p>
<p>比如 filter、limit， 当你需要使用 limit 的时候，使用 max、min 来代替更好，filter 的情况使用 select／remove 更好</p>
<h1 id="Comment"><a href="#Comment" class="headerlink" title="Comment"></a>Comment</h1><p>1.comment 需要的判断法则</p>
<blockquote>
<p>Anticipate which parts of your code will make readers say “Huh?” and comment those.</p>
</blockquote>
<p>2.对代码进行高层次的介绍</p>
<p>很多时候从代码整体的结构给出的注释很有价值</p>
<p>3.使用 example 来 comment</p>
<p>example 让人清晰明了</p>
<h1 id="condition-statement"><a href="#condition-statement" class="headerlink" title="condition statement"></a>condition statement</h1><p>1.尽量减少 if 语句</p>
<p>越少的 if 语句意味着代码可读性更好，代码更容易测试。</p>
<p>2.先处理简单的条件</p>
<p>先处理简单的条件会让人的思维更加清晰</p>
<p>3.避免出现嵌套的 if 语句</p>
<p>这样的代码看着就感觉很乱，如果能避免一定要避免</p>
<h1 id="break-down-giant-code-block"><a href="#break-down-giant-code-block" class="headerlink" title="break down giant code block"></a>break down giant code block</h1><p>如果能讲一块集中的代码很好的抽象成 mehtod 自然是更好的</p>
<h1 id="变量管理"><a href="#变量管理" class="headerlink" title="变量管理"></a>变量管理</h1><p>1.消除不必要的变量</p>
<p>比如像是连续出现的两次相同的变量名，完全没必要出现</p>
<p>2.缩小变量的 scope</p>
<p>这一点会让代码可读性好上不少，基本上可以让读代码的人少了许多记忆的压力</p>
<p>3.多使用 常量（只赋值一次的变量）</p>
<p>如果一个变量的类型是常量，那么自然对于测试、读方便很多，尤其是和第二点结合起来</p>
<h1 id="method／function"><a href="#method／function" class="headerlink" title="method／function"></a>method／function</h1><p>最重要的原则 one task at a time</p>
<h1 id="test"><a href="#test" class="headerlink" title="test"></a>test</h1><p>1.为 input output 写产生函数</p>
<p>没有必要每次都手动生成 input、output</p>
<p>2.减少对外部的依赖</p>
<p>写测试最麻烦的地方在于被测试的模块对外部以来比较高，因此如果能减少外部的依赖，那么 test 的工作量将会减少</p>

        
      
    </div>

    

    
  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/04/23/痛苦的反思/">Move Fast</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Apr 23, 2017
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>我放弃读 PhD，孤身来到杭州，想要在自己喜欢的领域作出一番成就，成为这个领域的专家，我始终抱有这样的幻想：<br>我是很厉害的，我可以在我喜欢的事情上做得很顺利，我会理所当然地成为一个专家。</p>
<p>然而事实却是：我和普通人一样。</p>
<p>在我写下这篇随笔的时候，其实我在工作上很不顺利，并且我自己也选择了逃避，我每天害怕着站会，并且期待着下班，不再和之前一样，充满了热情，就连这个周末也是过得非常颓废。</p>
<p>最终和往常一样，我的内疚感使我决定重新站立起来，我也真真切切地明白了这样的道理，没有人能够随随便便成功！如果这样想，我想自己也会变得更加坚强吧。</p>
<p>我想自己接下来的两个月里，要努力地在前端这方面进行更深入地探索与练习，一定要多写代码。</p>
<p>此外，我这周的工作让我发现自己的工作效率非常低下，我总结了一下原因：<br>写代码时会出现神思游离，导致出现很难发现的 bug（比如变量名写错了）<br>解决方案：<br>a. 模块化实现功能（在纸上列举出需要的步骤，一步步完成）<br>b. 在写代码的时候，一定要有意识地意识到自己在写不能出现低级错误、style 正确（使用各种 lint 工具）的code</p>
<p>最近，一个前辈负责写数据逻辑部分的代码，我看到他的写法，第一次感觉自己是太渺小了，我觉得自己要变得更厉害，要比他还厉害。</p>
<p>我现在的情况很是纠结，工作的事情多，自己又想看与语言无关的知识，同时又想看工作中使用的框架的源码。</p>

        
      
    </div>

    

    
  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/04/03/ES6-异步编程/">ES6-异步编程</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Apr 3, 2017
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2><p>异步编程是 Javascript 的一大特色，因为 Javascript 是单线程工作，因此如果没有异步方式的话，基本上用户体验将会是无法忍受的。</p>
<p>因此 Javascript 的语法对异步的看重使得其对异步编程用了比较大的力气去优化，本文将会对直到 ES7 的异步编程方式进行总结：</p>
<ol>
<li>Callback</li>
<li>Promise</li>
<li>Generator</li>
<li>asyn + await</li>
</ol>
<p>但是在阐述这些方式之前，有一个概念需要事先阐述的是 Javascript 的事件循环。</p>
<h3 id="事件循环-event-loop"><a href="#事件循环-event-loop" class="headerlink" title="事件循环(event loop)"></a>事件循环(event loop)</h3><p>event loop 是 Javascript 作为单线程语言完成非阻塞处理的重要机制，但其本身很容易理解，就是 Javascript 解释器的实现中会维护一个队列，task queue，当在执行语句中出现异步函数（比如 setTimeout）的时候，这样的函数是不会立即执行的，而是会被挂起，当空闲的时候，Javascript 解释器会处理这个异步操作，当处理完毕后，会在 task queue 里面插入一个事件，这个事件一般绑定了定义好的 callback。</p>
<p>下面是一个最简单的一个例子是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">console</span>.log(<span class="string">'World'</span>), <span class="number">0</span>)</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Hello'</span>)</div><div class="line"><span class="comment">// output: "Hello\nWorld"</span></div></pre></td></tr></table></figure>
<p>结果是在意料之中的，这是因为当调用 setTimeout 函数时，你即使设置了 timeout 是 0ms，callback 函数的执行仍然会被放入 task queue 里，等到当前的 call stack 被清空后（这里停止的时机我还不是很清楚，可能是 call stack 清空，但也可能是其他判定条件，比如跑了指定长度的代码）再回来从 task queue 里面取出最新的 event 来处理，也就是执行回调。</p>
<h3 id="异步编程方式"><a href="#异步编程方式" class="headerlink" title="异步编程方式"></a>异步编程方式</h3><p>有了 event loop 这个概念，那么对于操作异步函数就有帮助了，下面总结异步编程的方式，为了便于说明和调试，在需要使用异步函数的时候，本文都会使用 setTimeout 这个异步函数，其实本质上他和其他异步函数没什么区别，如果设置了 timeout 参数，就可看成其他异步函数的工作时间（这和 Java 中使用 Thread.sleep() 模拟线程运行是一个道理），下面会罗列目前 Javascript 的异步处理的几种常见的方式。</p>
<p>由于 setTimeout 的书写方式和正常异步函数不一致，此外不想在每次写 setTimeout 的时候，总是设置 timeout，所以先将其包装一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> afunc = <span class="function">(<span class="params">callback</span>) =&gt;</span> setTimeout(callback,<span class="number">1000</span>)</div></pre></td></tr></table></figure>
<p>此外，需要强调的是，这里所说的是异步编程方式，而不是异步函数，所谓异步编程方式（Asynchronized Programming)是指编写含有异步函数的代码的方式。</p>
<h4 id="Callback"><a href="#Callback" class="headerlink" title="Callback"></a>Callback</h4><p>所谓的 Callback 是最原始的方式，也就说说直接将 callback 函数作为异步函数的参数传入，比如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">afunc(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Hello"</span>);</div><div class="line">    afunc(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"World"</span>);</div><div class="line">        afunc(<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">console</span>.log(<span class="string">"!"</span>));</div><div class="line">    &#125;)</div><div class="line">&#125;)</div><div class="line"><span class="comment">//output: Hello\nWorld\n!</span></div></pre></td></tr></table></figure></p>
<p>当然如果写成原来的样子，应该是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Hello"</span>);</div><div class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"World"</span>);</div><div class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">console</span>.log(<span class="string">'!'</span>),<span class="number">1000</span>);</div><div class="line">    &#125;,<span class="number">1000</span>)</div><div class="line">&#125;,<span class="number">1000</span>)</div></pre></td></tr></table></figure>
<p>(之后就会直接使用 afunc)</p>
<p>可以发现这样写不很方便，而且很丑，于是在 ES6 中 Promise 应运而生。</p>
<h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><p>Promise 会提供刚好的异步编程体验，同样的例子可以这么写：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</div><div class="line">    afunc(<span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="string">"Hello"</span>);resolve();&#125;)</div><div class="line">&#125;).then(<span class="function"><span class="params">()</span>=&gt;</span><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>afunc(<span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="string">"World"</span>);resolve()&#125;)))</div><div class="line">.then(<span class="function"><span class="params">()</span>=&gt;</span><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>afunc(<span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="string">"!"</span>);resolve()&#125;)))</div></pre></td></tr></table></figure></p>
<p>这样就写成了链式的调用，但看上去非常繁琐，实际上我们可以将 afunc 封装一下：(为了不起冲突，命名成 afuncp)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> afuncp = <span class="function">(<span class="params">callback</span>)=&gt;</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</div><div class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">            callback();resolve()</div><div class="line">            &#125;, <span class="number">1000</span>);</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// then the statement can be expressed as:</span></div><div class="line">afuncp(<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">console</span>.log(<span class="string">"Hello"</span>))</div><div class="line">.then(<span class="function"><span class="params">()</span>=&gt;</span>afuncp(<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">console</span>.log(<span class="string">"World"</span>)))</div><div class="line">.then(<span class="function"><span class="params">()</span>=&gt;</span>afuncp(<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">console</span>.log(<span class="string">"!"</span>)))</div></pre></td></tr></table></figure></p>
<p>是不是简洁多了？<br>这里的改写实际上和 fs 中的 readFile 和 fs-readfile-promise 类似。</p>
<p>但即使如此，还有更方便的写法。</p>
<h4 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h4><p>如果能把异步编程的方式写成同步形式，那岂不是更加美观？</p>
<p>Generator 应运而生。</p>
<p>如果使用 Generator 的话，上面的写法将会变成：（注意这里使用的是 afuncp 而不是 afunc，当然使用 afunc 也是可以的，但是在下面要使用 Promise 的特性时就行不通了）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">genHelloWorld</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">yield</span> afuncp(<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">console</span>.log(<span class="string">"Hello"</span>));</div><div class="line">    <span class="keyword">yield</span> afuncp(<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">console</span>.log(<span class="string">"World"</span>));</div><div class="line">    <span class="keyword">yield</span> afuncp(<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">console</span>.log(<span class="string">"!"</span>));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> g = genHelloWorld();</div><div class="line">g.next()</div><div class="line">g.next()</div><div class="line">g.next()</div></pre></td></tr></table></figure></p>
<p>但是这么写却是不对的，（你可以发现三个字符串是同时出现的）为什么呢？因为虽然通过利用 Generator 执行到下一个 yield 会停止的特性来做到了，这样顺序执行了三个异步操作，但是和之前两个异步操作不一样，因为我们之前写的异步操作是有先后关系的，后一个异步操作必须是在前一个异步操作完成之后才能执行的。</p>
<p>也就是说 Generator 其实本身不支持异步操作的依赖执行（就是前一个先执行了，才能执行下一个），但是具备记录上次执行位置和状态使得它有可能完成异步编程方式，而其所欠缺的只是一个使得依赖执行能够运作的机制（姑且成为依赖运行器）。</p>
<p>下面我们就来实现这个机制，这个机制的关键地方在于控制依赖，以及自动运行：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">genController</span>(<span class="params">gen</span>)</span>&#123;</div><div class="line">    <span class="keyword">let</span> g = gen();</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">let</span> res = g.next();</div><div class="line">        <span class="keyword">if</span>(!res.done)&#123;</div><div class="line">            res.value.then(next);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    next();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// now let's run genHelloWorld</span></div><div class="line">genContorller(genHelloWorld);</div></pre></td></tr></table></figure></p>
<p>如果想在 production 环境中使用这样的机制，可以考虑 co 这个模块。</p>
<h4 id="async-await"><a href="#async-await" class="headerlink" title="async + await"></a>async + await</h4><p>通过上面的例子可以看出来，Generator 虽然在表达异步编程上非常具有优势，但是容易发现需要自己定义依赖运行器，于是 async 函数应运而生，其本质还是 Generator 但是却自带了依赖运行器。<br>下面试试，async 的写法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">genHelloWorld</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">await</span> afuncp(<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">console</span>.log(<span class="string">"Hello"</span>));</div><div class="line">    <span class="keyword">await</span> afuncp(<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">console</span>.log(<span class="string">"World"</span>));</div><div class="line">    <span class="keyword">await</span> afuncp(<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">console</span>.log(<span class="string">"!"</span>));</div><div class="line">&#125;</div><div class="line">genHelloWorld();</div></pre></td></tr></table></figure></p>
<p>很完美！</p>
<h4 id="Promise-的实现"><a href="#Promise-的实现" class="headerlink" title="Promise 的实现"></a>Promise 的实现</h4><p>之前有个工作上的前辈让我实现一个 Promise，叫我半个小时写出来一个有 resolve、then 功能的 Promise 类，结果我花了一晚上才实现出来。<br>代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PPromise</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(asyncF) &#123;</div><div class="line">        <span class="keyword">this</span>.cb = <span class="literal">null</span>; </div><div class="line">        <span class="keyword">this</span>.resolve = <span class="keyword">this</span>.resolve.bind(<span class="keyword">this</span>);</div><div class="line">        <span class="keyword">this</span>.then = <span class="keyword">this</span>.then.bind(<span class="keyword">this</span>);</div><div class="line">        <span class="comment">// convert resolve to async function calling</span></div><div class="line">        asyncF.apply(<span class="literal">null</span>, [<span class="function">(<span class="params">data</span>)=&gt;</span>setTimeout(<span class="function"><span class="params">()</span>=&gt;</span><span class="keyword">this</span>.resolve(data),<span class="number">0</span>)])</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    resolve(data) &#123;</div><div class="line">            <span class="keyword">var</span> cb = <span class="keyword">this</span>.cb;</div><div class="line">            <span class="keyword">if</span> (cb!==<span class="literal">null</span>)</div><div class="line">                cb.apply(<span class="literal">null</span>,[data]);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    then(cb) &#123;</div><div class="line">        <span class="keyword">var</span> newPromise = <span class="keyword">new</span> PPromise(<span class="function"><span class="params">()</span>=&gt;</span><span class="literal">null</span>);</div><div class="line">        <span class="comment">// link the next promise in the cb</span></div><div class="line">        <span class="keyword">this</span>.cb = <span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</div><div class="line">            <span class="keyword">var</span> d = cb.apply(<span class="literal">null</span>,[data]) </div><div class="line">            newPromise.resolve(d); </div><div class="line">        &#125;   </div><div class="line">        <span class="keyword">return</span> newPromise;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>实现的时候有两点需要注意的是：</p>
<ol>
<li>new Promise((resolve)=&gt;resolve(data)).then(console.log) 这个 resolve 调用是会被挂起的，这点也是这行代码 <code>asyncF.apply(null, [(data)=&gt;setTimeout(()=&gt;this.resolve(data),0)])</code> 的作用。</li>
<li>then 返回的是一个什么？ 答案是还是一个 Promise，这里的实现是返回一个新的 Promise 然后在当前 Promise 的 callback 中调用新 Promise 的 resolve 方法。</li>
</ol>

        
      
    </div>

    

    
  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/03/05/Git-实践/">Git-实践</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Mar 5, 2017
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h3 id="1-git-merge-时发生了什么-如何处理？"><a href="#1-git-merge-时发生了什么-如何处理？" class="headerlink" title="1. git merge 时发生了什么? 如何处理？"></a>1. git merge 时发生了什么? 如何处理？</h3><p>发生 conflict 的情况有两种：一种是不同 branch 之间的 merge 时发生，还有一种是同一 branch 上由于同步开发，出现相同父节点上出现了两次不同的 commit（实际上只有本人和远程的差异，再具体点说就是合作者与自己拥有同一个父节点，并且在我提交下一个 commit 之前已经提交了一个 commit，这时候我发现无论我 pull 还是 push 都会出现 conflicts ）。</p>
<p>对于这种情况，首先我想强调的是，不必紧张，git 是会保存所有的东西的，你们所有的更改都会保存下来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">A -----&gt; B1(sb else&apos;s commit) ---&gt; C</div><div class="line">|                                  | </div><div class="line">\                                  /</div><div class="line"> ------&gt; B2(your commit)----------</div></pre></td></tr></table></figure>
<p>首先，你得了解你的 repo 处在什么状态——实际上是处于一个 merge 状态，这种状态你需要处理所有 unmerged file。</p>
<p>然后，你有两个选择，手动消除 unmerged 的地方，然后使用 <code>git add &lt;file&gt;</code> 来表示 merge 完毕，之后就可以提交新的 commit（需要注意的是这时的 commit 是一个 merge 类型的结点，它有两个父节点，这点下面会因此而出现意外情况）。在提交新的 commit 之前，你还可以使用 <code>git merge --abort</code> 来取消这次 merge。</p>
<p>但是如果出现这样的情况，merge 完毕后发现自己的 merge 做的有问题，不必担心，由上面的图可以知道，之前的冲突结点都保存着，那么该如何恢复呢？</p>
<p>很简单，通过 revert 恢复是最安全的方式（注意，revert 和 reset 不一样，reset 是恢复到参数指定的 commit 的状态，而 revert 是回滚指定 commit 的状态到上一次 commit）</p>
<p>但是如果你使用 <code>git revert &lt;B2&#39;s SHA&gt;</code> 会出 conflicts，这是因为你理解错了 revert 的含义（通过 git revert –abort 可以回滚）,而出现 conflicts 的原因是一般 revert 只会用作 <code>revert HEAD</code>，因此 git 知道回滚到当前 commit 的上一次 commit的方法，没有其他选择，若是回滚到指定版本的话，git 并不知道如何跨 commit 回滚，因此必须要人来手动 merge 一下。</p>
<p>在这里的情况我们得使用 <code>git revert HEAD</code>，但是即使如此，仍然不对，而且是出错，这是因为，回滚 C 的时候，发现 C 有两个父节点，因此必须指定回滚到哪一个结点才行，那么如何知道相应父节点的编号呢？通过 <code>git log</code> 即可查看父节点的顺序，有了顺序使用 <code>git revert HEAD -m &lt;number&gt;</code> 来回滚到指定的父节点（注意编号从 1 开始）。</p>
<h3 id="2-arc-如何结合-phabricator-使用？"><a href="#2-arc-如何结合-phabricator-使用？" class="headerlink" title="2. arc 如何结合 phabricator 使用？"></a>2. arc 如何结合 phabricator 使用？</h3><p>phabricator 是一种工程代码管理集成工具，arc 是进行 phabricator 上的 code review 的重要工具，那么如何使用 arc 呢？</p>
<h4 id="安装-arc"><a href="#安装-arc" class="headerlink" title="安装 arc"></a>安装 arc</h4><p>参考 <a href="https://secure.phabricator.com/book/phabricator/article/arcanist_quick_start/" target="_blank" rel="external">这里</a></p>
<h4 id="一次-feature-bug-的提交过程"><a href="#一次-feature-bug-的提交过程" class="headerlink" title="一次 feature/bug 的提交过程"></a>一次 feature/bug 的提交过程</h4><ol>
<li><code>git pull</code> 保证 master 分支最新</li>
<li><code>git checkout -b feature/xxx</code> 进行代码开发</li>
<li><code>git add &lt;files needed to be committed&gt;; git commit -m &quot;...&quot;</code> commit 代码</li>
<li><code>arc diff</code> 这个时候提交 diff，根据提示需要指定 diff 的 base，如果你只是 commit 过一次，那么一般使用 HEAD^ 作为 base（这也是默认选项）如果觉得不放心的话，最好使用 <code>arc diff --preiview</code> 来确认一下自己这次 diff 的提交是否出错</li>
<li>代码 review 时出现需要改动的地方，那么改动代码后，使用 <code>git commit --amend</code> 来进行 commit，这样就会保证始终只有一次 commit，这样的话，就会方便每次 arc diff 的时候，不必指定 base</li>
<li>review 通过以后 <code>arc land</code> 会将该分支 merge 到 master</li>
</ol>
<h4 id="如果-land-diff-的时候发现-master-已经更新，并且-merge-有冲突"><a href="#如果-land-diff-的时候发现-master-已经更新，并且-merge-有冲突" class="headerlink" title="如果 land diff 的时候发现 master 已经更新，并且 merge 有冲突"></a>如果 land diff 的时候发现 master 已经更新，并且 merge 有冲突</h4><ol>
<li>本地 merge 一次（解决冲突、add file、commit）</li>
<li>再次更新 diff，将 base 设为最新的 master head，等待 review<br>更好的解决办法是：</li>
<li><code>git checkout master</code></li>
<li><code>git pull</code></li>
<li><code>git checkout &lt;diff-branch&gt;</code></li>
<li><code>git rebase master</code></li>
<li>若是出现冲突，merge 完毕后，可以使用 <code>rebase --continue</code></li>
<li><code>arc diff HEAD^</code></li>
</ol>
<h3 id="3-git-如何切换到任意结点下的某一个文件？"><a href="#3-git-如何切换到任意结点下的某一个文件？" class="headerlink" title="3. git 如何切换到任意结点下的某一个文件？"></a>3. git 如何切换到任意结点下的某一个文件？</h3><p><code>git checkout &lt;commit-hash&gt; path/to/file</code></p>

        
      
    </div>

    

    
  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/02/27/React-Redux-入门坑总结/">React-Redux 入门坑总结</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Feb 27, 2017
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>我这个星期基本上在工作之余都在研究 React 和 Redux，我之前对这部分知识完全没用接触过，期间遇到很多坑，尤其是在想自己能够完成一个独立的比较小的 React App 的时候，发现出现了很多意想不到的事情，下面是我这个星期的总结。</p>
<p>注意，本文不是 React 和 Redux 的 tutorial，按道理讲，官方文档已经写的比较好了，但是对于新手来说可能不是很容易上手，因此，如果你看完了官方文档，在自己动手实现自己的第一个 React App 的时候，如果先看一下本文可能会得到一些启示，从而绕过一些坑。</p>
<p>文章分为两个部分，第一部分是关于 React 的内容，第二部分是关于 Redux 的内容（需要注意的是，React 和 Redux 不是必须一起使用的，实际上本文写的时候，Redux 已经有式微的趋势了）。</p>
<p>文中使用的原本 code 来自于 facebook 的 React 项目的 <a href="https://codepen.io/ericnakagawa/pen/vXpjwZ?editors=0010" target="_blank" rel="external">tutorial</a>。</p>
<h2 id="阅读之前最好先看过……"><a href="#阅读之前最好先看过……" class="headerlink" title="阅读之前最好先看过……"></a>阅读之前最好先看过……</h2><ol>
<li>React 的 <a href="https://codepen.io/ericnakagawa/pen/vXpjwZ?editors=0010" target="_blank" rel="external">tutorial</a>。</li>
<li>webpack 的简单介绍</li>
<li>Redux 的基础部分</li>
</ol>
<h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><p>首先对 React 的特点做一个总结，React 是 facebook 推出的一个前端框架（注意前端不一定是指 web），其最大的特点在于，<strong>视图组件化</strong>。</p>
<p>我两年前（2015）的时候，还没有接触到 React 这种东西，那时候我只知道 Dom 编程，当时就感觉，开发前端页面非常繁琐，尤其是再结合 PHP 使用，其主要问题就是 JS 代码就是脚本，复用性不高，视图的响应逻辑逻辑很混乱，而 React 很好地解决了这个问题，通过将想要构建的视图直接分解成具有层级的组件，这样就可以大大提高视图组件的复用性，此外，每一个组件都具备相应的 props 和 state，前者是组件的属性值，后者是组件的状态，两者的区别就在于：前者是由父组件提供的组件属性（所以在组件内部是只读的），后者是私有的组件属性（用于保存这个组件的状态，从而实现自更新）:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这是 ReactComponent.js 的一段代码</span></div><div class="line">ReactComponent.prototype.setState = <span class="function"><span class="keyword">function</span> (<span class="params">partialState, callback</span>) </span>&#123;</div><div class="line">  !(<span class="keyword">typeof</span> partialState === <span class="string">'object'</span> || <span class="keyword">typeof</span> partialState === <span class="string">'function'</span> || partialState == <span class="literal">null</span>) ? process.env.NODE_ENV !== <span class="string">'production'</span> ? invariant(<span class="literal">false</span>, <span class="string">'setState(...): takes an object of state variables to update or a function which returns an object of state variables.'</span>) : _prodInvariant(<span class="string">'85'</span>) : <span class="keyword">void</span> <span class="number">0</span>;</div><div class="line">  <span class="keyword">this</span>.updater.enqueueSetState(<span class="keyword">this</span>, partialState);</div><div class="line">  <span class="keyword">if</span> (callback) &#123;</div><div class="line">    <span class="keyword">this</span>.updater.enqueueCallback(<span class="keyword">this</span>, callback, <span class="string">'setState'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其中最重要的一段代码就是   <code>this.updater.enqueueSetState(this, partialState);</code>，可以看出来，当使用了 setState 后，便会将新的状态放入 updater 的更新队列中。</p>
<h3 id="搭建起一个可以构建-React-App-的本地环境"><a href="#搭建起一个可以构建-React-App-的本地环境" class="headerlink" title="搭建起一个可以构建 React App 的本地环境"></a>搭建起一个可以构建 React App 的本地环境</h3><p>之所以会提到这一点，是因为 facebook 提供的 <a href="https://codepen.io/ericnakagawa/pen/vXpjwZ?editors=0010" target="_blank" rel="external">starter code</a> 是在线的版本，当你把代码复制到本地的时候，根本就用不了。</p>
<p>这时候必须使用到一个方便的工具了，叫做 <a href="https://webpack.github.io/" target="_blank" rel="external">webpack</a>，这是一个打包 js 代码的工具，通过简单的配置，便可以使用其将所有的 js 代码打包起来，比如叫做 <em>bundle.js</em>，然后直接在 <em>index.html</em> 中引用这个脚本。</p>
<p>但是，仅仅如此还不够，因为上述代码使用的是 ES6 + JSX 的形式，因此必须还得配置好 webpack 的配置文件 <em>webpack.config.js</em>，在 webpack 这个工具之中有 loader 这个概念，loader 的意思其实就是解析其他形式的语言到 js 的形式，由第三方提供，在这里我们使用 babel 这个 loader，此外必须安装 babel 的另外两个 loader：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i babel-loader babel-preset-es2015 babel-preset-react babel-core -S</div></pre></td></tr></table></figure></p>
<p>然后要在 <em>webpack.config.js</em> 里配置好：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">    <span class="attr">entry</span>:<span class="string">'./index.js'</span>,</div><div class="line">    <span class="attr">output</span>:&#123;</div><div class="line">        <span class="attr">filename</span>:<span class="string">"bundle.js"</span>,</div><div class="line">        <span class="attr">path</span>:path.resolve(__dirname,<span class="string">'dist'</span>)</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">module</span>:&#123;</div><div class="line">        <span class="attr">loaders</span>:[</div><div class="line">          &#123;</div><div class="line">            <span class="attr">test</span>: <span class="regexp">/(\.jsx|\.js)$/</span>,</div><div class="line">            <span class="attr">loaders</span>: <span class="string">'babel-loader'</span>,</div><div class="line">            <span class="attr">query</span>:&#123;</div><div class="line">                <span class="attr">presets</span>:[<span class="string">'es2015'</span>,<span class="string">'react'</span>,<span class="string">'stage-0'</span>]</div><div class="line">            &#125;,</div><div class="line">          &#125;,</div><div class="line">          &#123;</div><div class="line">            <span class="attr">test</span>: <span class="regexp">/\.scss$/</span>,</div><div class="line">            <span class="attr">loaders</span>: [<span class="string">'style'</span>, <span class="string">'css'</span>, <span class="string">'sass'</span>],</div><div class="line">          &#125;,</div><div class="line">          &#123;</div><div class="line">            <span class="attr">test</span>: <span class="regexp">/\.html$/</span>,</div><div class="line">            <span class="attr">loader</span>: <span class="string">'file?name=[name].[ext]'</span></div><div class="line">          &#125;,</div><div class="line">        ],</div><div class="line"></div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="使用-JSX-的注意点"><a href="#使用-JSX-的注意点" class="headerlink" title="使用 JSX 的注意点"></a>使用 JSX 的注意点</h3><p>JSX 其实就是将 html 的标签引入进了 js 中，但是在使用上也有必须要注意的问题，我是第一次使用 JSX，因此就遇到了一些问题。</p>
<ol>
<li>JSX 本质上就是一个 expression，这一点很重要，因此它可以被 return 返回，可以用数组存储</li>
<li>JSX 的 tag 必须成对出现，这一点和 xml 的语法很像，不可省略（若是省略，首 tag 之后的内容会被认为全在 tag 之内）</li>
<li>JSX 中虽然可以通过 <code>{var}</code> 这样的方式，来加入上下文的出现的变量，但是在 JSX 的 tag 之间不能出现 expression 以外的 statement，这里之所以会提到这一点是因为想说不要试图通过在 tag 之间加入 for 循环来进行相同类型的 element 的生成（想要达到这一效果，可以使用数组来存储中间的 element，然后最后一起提供给 render 函数</li>
</ol>
<h3 id="React-组件的书写"><a href="#React-组件的书写" class="headerlink" title="React 组件的书写"></a>React 组件的书写</h3><p>写 React 组件有两种方法：class 继承 或者 提供一个 function。</p>
<p>在使用 class 继承的时候，有一点必须要注意，class 是 ES6 的语法，因此必须使用 babel-ex2015 这个 loader 来解析，此外根据 es6 的语法，在 class 内部使用方法的时候，必须通过 <code>this</code> 来引用。</p>
<p>在使用 function 的时候，一种简洁的方法便是使用 arrow function，但是需要注意的是 arrow function 的时候，提供的参数只有一个，就是用来赋给 props 的，code 里面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> Board = <span class="function">(<span class="params">&#123;nextPlayer,squares,handleClick&#125;</span>)=&gt;</span>&#123;...&#125;</div></pre></td></tr></table></figure>
<h3 id="javascript-的自动插入-semicolon-ASI-auto-semicolon-insertion"><a href="#javascript-的自动插入-semicolon-ASI-auto-semicolon-insertion" class="headerlink" title="javascript 的自动插入 semicolon (ASI, auto semicolon insertion)"></a>javascript 的自动插入 semicolon (ASI, auto semicolon insertion)</h3><p>这一点是我这次过程中才发现的，真的让我很无力，关于这一点有很详细的文档记载，可以参考这个 SO <a href="http://stackoverflow.com/questions/2846283/what-are-the-rules-for-javascripts-automatic-semicolon-insertion-asi" target="_blank" rel="external">问答</a>，在这里我只想强调一点，就是关于 return 的 ASI：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span></div><div class="line">&#123;</div><div class="line">    <span class="attr">a</span>:<span class="number">1</span>,</div><div class="line">    <span class="attr">b</span>:<span class="number">2</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// will be transformed to:</span></div><div class="line"><span class="keyword">return</span> ;</div><div class="line">&#123;</div><div class="line">    <span class="attr">a</span>:<span class="number">1</span>,</div><div class="line">    <span class="attr">b</span>:<span class="number">2</span>,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h2><p>Redux 的设计思想在我看来还是很先进的，在这里先以我的理解做一下简单的总结。</p>
<p>虽然说 React 和 Redux 和 React 没有必然联系，但是在我看来，没有类似于 React 的这种<strong>视图组件化</strong>的思想的话，那么 Redux 就是空中楼阁，Redux 的设计理念是对 React 的一大应用，它所做的事情其实就是将<strong>视图的响应逻辑集中化</strong>，React 组件在设计庞大之后，将会出现难以避免的视图响应逻辑复杂（复杂之处在于不同组件之间的交互），这也是为什么 React 的官方文档里总是提倡 <strong>lift up state</strong>，通过这样来避免小组件之间的通信。</p>
<p>在 Redux 的设计之外，有一个重要的理念，就是 Component 和 Container 的设计思想，这也是 Redux 官方文档推荐的一篇 <a href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0" target="_blank" rel="external">post</a>。这和 React 的 <strong>lift up state</strong> 思想很相似，其实在最后所有的状态都集中到的那个 Component 就是这里的 Container，因此 Redux 在与 React 的结合使用中，你会发现，Redux 实际上将 state 从 Component 中抽离了，当然也并非存在于 Container，而是存在于全局，Container 只是访问全局 state 的地方而已，那么 UI 的更新又是如何做的呢？Redux 通过 state 的改变，然后将这种改变映射到 props 中去，然后会导致相应的 Component UI 发生变化。</p>
<h3 id="Redux-的流程"><a href="#Redux-的流程" class="headerlink" title="Redux 的流程"></a>Redux 的流程</h3><p>官方文档的 tutorial 写的很好了，但是我看完之后，真正轮到我实现的时候又变得懵逼了，究其原因其实在于不理解 Redux 的控制流程。</p>
<p>因此 Redux 的入门坑就在于如何正确理解它的控制流程，下面是我的理解：<br>state 作为存储于全局的变量，只要在一开始正确设置了 store，那么在这个 App 的内部任何地方都可以访问到 App 的状态（通过 <code>store.getState()</code>）</p>
<p>reducer 实际上就是做了一件事，描述了整个状态机，(previous state, action) =&gt; (next state)</p>
<p>在设计的时候，要分别实现相应的 Component 和 Container，其中 Container 中不要涉及 state 的访问，它对 Redux 是一无所知的，而 Container 负责做两件事，分别对应着两个个需要实现的函数：mapStateToProps 和 mapDispatchToProps。</p>
<p>其实这两个函数的名字可以任意取，但是这样取可以表明他们的含义，从名字可以看出它们都是给 Component 的 props 赋值，但赋值的对象和目的有所区别，前者负责描述 (current state) =&gt; (current props)，也就是在状态改变的时候如何更新 UI；后者做的是将 dispatch 动作赋值给 Component 的 props 中的事件属性，比如 onclick ，一般只会执行一次，用于触发 action，从而依据自定义的 reducer 推动 state 的更新。</p>
<p>因此，整个触发流程便是含有 dispatch action 的 onClick 被触发了，然后 reducer 指明了下一个 state，然后 mapStateToProps 被调用了，然后 Component 被重新绘制了。</p>

        
      
    </div>

    

    
  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/02/17/JavaScript-ES5-总结/">JavaScript ES5 总结</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Feb 17, 2017
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>JavaScript 的语法让我感到非常不舒服，究其原因其实是因为两点：</p>
<ol>
<li>动态语言</li>
<li>原型编程</li>
</ol>
<p>对于动态语言，我个人始终认为是不符合大型 project 的要求的，因为动态语言的特性导致阅读代码的时候非常不顺利，比如你看到一个 function 的参数时候，你完全不知道它是怎样的结构，但是像 Java 这样的强类型语言，每一个参数都有类型，就使得对于每一个参数你都知道它实实在在的含义（可以去查看参数类型的定义）。<br>此外原型编程，我迄今看不出其优势所在，不仅每一个对象的原型都可以被随意改变，而且根本没有访问控制。</p>
<p>但尽管如此，我个人认为 JavaScript 还是更加现代化的编程语言，比如它的 function 可以作为对象任意传递，这一点和 Python 类似，对于异步编程可以说是非常直观地支持。<br>然而 JavaScript 的发展在 2015 年 ES6 发布后，就迎来了非常大的增强，我想为了更好的学习 ES6，对之前版本的深层次的理解还是需要的，相当于打好基础才能更好地前进。<br>在本篇 post 中，我主要是对自己看过的 Dmitry Soshnikov 的一系列关于 ES3-ES5 的 <a href="http://dmitrysoshnikov.com" target="_blank" rel="external">posts</a> 总结，主要包含 JavaScript 中最迷惑人的两个部分：</p>
<ol>
<li>变量管理</li>
<li>原型编程</li>
</ol>
<h2 id="变量管理"><a href="#变量管理" class="headerlink" title="变量管理"></a>变量管理</h2><p>这里使用的变量管理并不是指硬件层面的实现，而是指 JavaScript 的变量存储的抽象模型。另外，在概念上，ES3 和 ES5 有着几个区别，因此会分别描述。</p>
<h3 id="ES3"><a href="#ES3" class="headerlink" title="ES3"></a>ES3</h3><h4 id="Execution-Context-EC"><a href="#Execution-Context-EC" class="headerlink" title="Execution Context(EC)"></a>Execution Context(EC)</h4><p>在 JavaScript 中有两种 EC：global context 和 function context。<br>不同的 context 的管理是用 stack 模式管理的，举个例子，在 global context 下定义了一个 function func，那么整个 EC stack 就是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">EC Stack = &#123;</div><div class="line">    funcContext,</div><div class="line">    globalContext,</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果从 funcContext 退出那么，EC Stack 将会只剩下 globalContext，符合 Stack 的管理方式。<br>EC 有着许多重要的 property，用以在运行时使用，而在本篇 post 中，着重强调变量管理这一个问题，因此会探究其相关属性。</p>
<h4 id="Variable-Object-VO-Activation-Object-AO"><a href="#Variable-Object-VO-Activation-Object-AO" class="headerlink" title="Variable Object(VO) / Activation Object(AO)"></a>Variable Object(VO) / Activation Object(AO)</h4><p>VO 和 AO 其实类似于符号表(symbol table)，用以集中管理变量，并且这是 EC 的属性，在 ES6 之前是没有 var 之外的变量定义方式的(有隐式定义变量，下面会提到)，而对 var 的处理会在<strong>静态分析</strong>进行，并且将定义的变量名填入 VO/AO，但是并不会直接对其赋值，而是等到执行到赋值语句的时候才会：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// now VO = &#123;</span></div><div class="line"><span class="comment">//     a: undefined,</span></div><div class="line"><span class="comment">// &#125;</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></div><div class="line"><span class="keyword">var</span> a = <span class="number">13</span>;</div><div class="line"></div><div class="line"><span class="comment">// now VO = &#123;</span></div><div class="line"><span class="comment">//     a: 13,</span></div><div class="line"><span class="comment">// &#125;</span></div></pre></td></tr></table></figure></p>
<p>这里既然都是符号表，为什么有 VO 和 AO 的区别呢？<br>VO 其实是指 global context 的符号表，而 AO 是指 function context 的符号表，之所以有这两者的区别是因为 function context 有着不一样的符号管理，总共包括三类符号：</p>
<ol>
<li>arguments：即 function 的参数</li>
<li>functions：function 内部定义的 function，在静态分析期间，如果符号与 arguments、variables 中的有冲突，直接替代(function 提升)</li>
<li>variables：function 内部定义的变量，如果和 1、2 有冲突，在静态分析期间不会造成影响，在执行期间会直接替代 1 中的冲突项(理所当然的，后来覆盖)，与 2 的互相替代也符合后来覆盖原则</li>
</ol>
<p>直接看一个例子就知道区别了：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">f</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(f);</div><div class="line">    <span class="keyword">var</span> f = <span class="number">4</span>;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">    <span class="built_in">console</span>.log(f);</div><div class="line">&#125;</div><div class="line">func(<span class="number">3</span>);</div><div class="line"><span class="comment">// output:</span></div><div class="line"><span class="comment">// [Function: f]</span></div><div class="line"><span class="comment">// 4</span></div></pre></td></tr></table></figure></p>
<p>这段的最后还要说明一下隐式声明的问题，上面提到如果直接给一个变量赋值(不用 var)也是可以的，但是其实不是向 VO 中添加符号，而是给当前的 EC 下的 this 变量添加了一个属性而已。<br>看下面的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">x = <span class="number">3</span>;</div><div class="line"><span class="keyword">var</span> a = <span class="number">4</span>;</div><div class="line"><span class="keyword">delete</span> a;</div><div class="line"><span class="keyword">delete</span> x;</div><div class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 4</span></div><div class="line"><span class="built_in">console</span>.log(x); <span class="comment">// Reference Error</span></div></pre></td></tr></table></figure></p>
<h3 id="Scope-Chain-SC"><a href="#Scope-Chain-SC" class="headerlink" title="Scope Chain(SC)"></a>Scope Chain(SC)</h3><p>按道理说有了 EC 和 VO，那么便可以在任何一个特定的 EC 下进行变量访问，但是如果出现当前变量无法再当前 EC 下找到，那么该如何处理呢？为了解决这种情况，SC 被引入自然是很正常的事情，而 SC 和其他语言的构造方法基本一致：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SC(ECStack[top]) = VO/AO + SC(ECStack[top<span class="number">-1</span>]);</div><div class="line">ECStack[<span class="number">0</span>] === globalContext;</div></pre></td></tr></table></figure></p>
<p>但需要注意的是，JavaScript 并没有 block 的概念，这是和其他主流语言的最大区别之一，也正因为如此只有 function 才能创造新的 context，因此常常会说一个 function 的 SC，但实际上是 EC 的 SC。因此对于 function 中的变量解析，自然是很重要的，但其实也很简单，只需要注意一点 <strong>function 的 SC 是静态分析确立的</strong>，会在运行前把需要用的变量的 Reference 记录下来：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">3</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(x);</div><div class="line">&#125;</div><div class="line">func(); <span class="comment">// output: 3</span></div><div class="line">x = <span class="number">4</span>;</div><div class="line">func(); <span class="comment">// output: 4</span></div></pre></td></tr></table></figure></p>
<p>此外，with 和 catch 会把其引入的变量加入到当前 SC 的最前面:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> obj  = &#123;</div><div class="line">        <span class="attr">x</span>: <span class="number">3</span>,</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> x = <span class="number">4</span>;</div><div class="line">    <span class="keyword">with</span>(obj)&#123;</div><div class="line">        <span class="built_in">console</span>.log(x);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">func();<span class="comment">// output: 3</span></div></pre></td></tr></table></figure></p>
<p>还有一点比较重要的是，因为 JavaScript 的有着 prototype，因此当顺着 SC 找到最后，可以访问到 Object 的 prototype 上去，可以看下面这个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(x);</div><div class="line">&#125;</div><div class="line"><span class="built_in">Object</span>.prototype.x = <span class="number">10</span>;</div><div class="line">foo(); <span class="comment">// 10</span></div></pre></td></tr></table></figure></p>
<h4 id="属性访问"><a href="#属性访问" class="headerlink" title="属性访问"></a>属性访问</h4><p>讲到这里，有了 EC、VO、SC，我们看似便可以对几乎所有的变量进行访问了，但是还有一种情况没有考虑，那就是 object 的属性访问，而在属性访问中，还有一个特别的例子，就是 this 的属性访问。</p>
<h5 id="Reference-Type-RT"><a href="#Reference-Type-RT" class="headerlink" title="Reference Type(RT)"></a>Reference Type(RT)</h5><p>属性访问问题解决的本质其实在于如何定义这样的访问方法，而 JS 的做法是通过 RT 来解决，RT 的产生只在两者情况下：</p>
<ol>
<li>处理变量名(identifier)[这里表明，普通变量的访问其实也是通过 RT 来解决的]</li>
<li>处理属性访问符(property accessor)</li>
</ol>
<p>而 RT 的基本结构如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="number">3</span>;</div><div class="line"><span class="comment">// fooReferenceType = &#123;</span></div><div class="line"><span class="comment">//    base: null,  =&gt; null will be transformed to globalContext's VO</span></div><div class="line"><span class="comment">//    propertyName: foo,</span></div><div class="line"><span class="comment">//&#125;</span></div></pre></td></tr></table></figure>
<p>当引用 foo 变量的时候，首先便会得到一个 fooReferenceType，然后每一个 RT 都有一个获取属性值的方法(GetValue)，这样就解决了属性访问的问题(其实说到可以发现，JS 里所有的变量访问都是属性访问，只不过没有指定 object 的地方基本上使用的 SC 上一层 VO/AO)。</p>
<h5 id="this-绑定"><a href="#this-绑定" class="headerlink" title="this 绑定"></a>this 绑定</h5><p>this 的使用一般是如下情况：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">x</span>:<span class="number">1</span>&#125;;</div><div class="line">obj.func();</div></pre></td></tr></table></figure>
<p>这里在 func 的内部如何知道 this 这个 object 是什么呢？这里就涉及到了 this 的 binding 问题。<br>其实 this 的绑定规则很简单，可以这么说 <strong>this 的绑定完全由 function 的调用方式决定</strong>，这是因为 this 绑定的 object 就是 <strong>function 前面的变量的 RT 的 base</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj1 = &#123;</div><div class="line">    <span class="attr">x</span>: <span class="number">1</span>,</div><div class="line">    <span class="attr">func</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</div><div class="line">        &#125;,</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> obj2 = &#123;</div><div class="line">    <span class="attr">x</span>: <span class="number">2</span>,</div><div class="line">    <span class="attr">func</span>: <span class="literal">undefined</span>,</div><div class="line">&#125;;</div><div class="line">obj1.func(); <span class="comment">// output 1</span></div><div class="line">obj2.func = obj1.func;</div><div class="line">obj2.func(); <span class="comment">// output 2</span></div><div class="line">(obj2.func = obj1.func)(); <span class="comment">// output undefined</span></div></pre></td></tr></table></figure>
<p>这是一个很经典的例子，1 和 2 的输出根据上面的理论是理所当然的结果，但是最后一个 undefined 的结果可能就有点令人费解了。它背后的机制是这样的，<code>(obj2.func = obj1.func)</code> 括号内一个表达式，并不是一个变量名(identifier)，当然也不是属性访问器(property accessor)，因此对它解析不会产生 RT，也因此其 this 的绑定为 null，而 null 作为 this 的值在 non-strict 模式下是会被转化成 globalContext 的 VO 的。</p>
<h2 id="ES5"><a href="#ES5" class="headerlink" title="ES5"></a>ES5</h2><h3 id="Call-Stack"><a href="#Call-Stack" class="headerlink" title="Call Stack"></a>Call Stack</h3><p>将 EC 的称谓正式变为 Call Stack，本质并没有太多变化。</p>
<h3 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h3><p>ES5 管理变量的方式发生了比较大的变化，首先不在使用 VO 和 AO 了，统一成了 Environment，但是 Environment 分为两类，Variable Environment(VE) 和 Lexical Environment(LE) 两种，但是和 VO/AO 的分类并没有直接关系，其实 VE 本质上和 ES3 中的 VO/AO 是同一个东西，负责管理所有的变量访问，LE 的提出是为了解决这样一个特定问题：<strong>with 下的 function expression 中的变量访问</strong>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(x);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">with</span> (&#123;<span class="attr">x</span>: <span class="number">2</span>&#125;) &#123;</div><div class="line">    <span class="comment">// this is a function expression</span></div><div class="line">    <span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(x);</div><div class="line">    &#125;;</div><div class="line">    foo(); <span class="comment">// 1, from VariableEnvrionment</span></div><div class="line">    bar(); <span class="comment">// 2, from LexicalEnvrionment</span></div><div class="line">&#125;</div><div class="line">foo(); <span class="comment">// 1</span></div><div class="line">bar(); <span class="comment">// still 2</span></div></pre></td></tr></table></figure></p>
<p>其实一般情况下，LE 只是 VE 的一个复制值，但是当出现例子这种情况的时候，必须在不破坏 VE 的情况下(因为 <code>foo</code> 的调用需要用到 <code>x = 1</code>)，同时提供另一套 <code>{x: 2}</code> 会被先访问的 Environment(<code>bar</code> 的调用要用到 <code>x:2</code>)，于是会在进入 with block 的时候，保存好当前的 LE，同时改变 LE 为需要的 LE，在 with block 结束的时候恢复。</p>
<h3 id="Enviroment-Record-ER"><a href="#Enviroment-Record-ER" class="headerlink" title="Enviroment Record(ER)"></a>Enviroment Record(ER)</h3><p>每一个 Environment 的结构会包含一个 ER 以及一个 outer，outer 其实就是上一层的 Environment，这点和 SC 很类似，不过是不完全一样的，下面的一个例子可以说明问题：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> y = <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">globalEnvironment = &#123;</div><div class="line">    <span class="attr">environmentRecord</span>: &#123;</div><div class="line"> </div><div class="line">        <span class="comment">// built-ins:</span></div><div class="line">        <span class="built_in">Object</span>: <span class="function"><span class="keyword">function</span>,</span></div><div class="line">        <span class="title">Array</span>: <span class="title">function</span>,</div><div class="line">        // <span class="title">etc</span> ...</div><div class="line">    </div><div class="line">        // <span class="title">our</span> <span class="title">bindings</span>:</div><div class="line">        <span class="title">x</span>: 1,</div><div class="line">        <span class="title">func</span>: <span class="title">function</span>,</div><div class="line"></div><div class="line">    &#125;,</div><div class="line"> </div><div class="line">    <span class="title">outer</span>: <span class="title">null</span> // <span class="title">no</span> <span class="title">parent</span> <span class="title">environment</span></div><div class="line"> </div><div class="line">&#125;;</div><div class="line"> </div><div class="line">// <span class="title">environment</span> <span class="title">of</span> <span class="title">the</span> "<span class="title">foo</span>" <span class="title">function</span></div><div class="line"> </div><div class="line"><span class="title">fooEnvironment</span> = &#123;</div><div class="line">    environmentRecord: &#123;</div><div class="line">        <span class="attr">y</span>: <span class="number">2</span>,</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">outer</span>: globalEnvironment</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>也许你有这样的疑惑，为什么需要做这样的改变呢？<br>答案是为了 Efficiency！<br>需要提到的是，规定(specification)并不提倡将 ER 实现为一个 simple object，这意味着各大 Engine 在这里可以提供自定义的优化！仔细想一想就会发现 SC 的设计会导致一层一层地查找某个变量，这个效率实在是太过低下，为什么不把会用到的变量放入当前 ER 中以提供直接的访问？此外还可以将不用到的变量不保存，这两点可以通过静态分析做到，V8 Engine 却是也是这样做的。<br>此外 environment record 有两种类型 decorative environment record(VER) 和 object environment record(OER)，两者的区别在于前者处理 function activition 以及 catch 时的 environment record(相当于以前的 AO)，后者用于处理 global context 下的 function、variable 以及 with 语句下的变量 binding，这只是规定(specification)上的区别，在实际实现中，并没有这个标志来指定 ER 的区别。</p>
<h2 id="原型编程"><a href="#原型编程" class="headerlink" title="原型编程"></a>原型编程</h2><h3 id="proto-和-prototype-的区别"><a href="#proto-和-prototype-的区别" class="headerlink" title="__proto__ 和 prototype 的区别"></a>__proto__ 和 prototype 的区别</h3><p>在阐述原型之前，必须先澄清这两个概念的区别，其实说穿了也很简单，一个 object 的原型实际上就是 __proto__，那么 prototype 又是什么呢？<br>直接看如下一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Constructor</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.x = <span class="number">3</span>;</div><div class="line">&#125;</div><div class="line">Constructor.prototype. y = <span class="number">4</span>;</div><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Constructor();</div><div class="line"><span class="built_in">console</span>.log(obj.__proto__ === Constructor.prototype) <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(obj.x, obj.y) <span class="comment">//3, 4</span></div></pre></td></tr></table></figure>
<p>看到这里你就知道了，当使用 <code>new Cnostructor()</code> 来创建对象的话，那么 Constructor 的 prototype 便会是新创建对象的 __proto__。<br>值得注意的是，上面这个例子中，x 和 y 的查询是不同的，x 属于 obj 自己的属性，而 y 是属于其原型的属性。</p>
<p>因此一般说来，prototype 是 function 才有的属性，而所谓的原型编程实际上就是指使用 function 来进行 __proto__ 的创建与传递。</p>
<p>另外，这里给出 Object 和 Function 的 __proto__ 和 prototype:（注意 Object 和 Funtion 都是 function 类型的）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&gt; Function.__proto__</div><div class="line">[Function]</div><div class="line">&gt; Function.__proto__.__proto__</div><div class="line">&#123;&#125;</div><div class="line">&gt; Function.__proto__.__proto__.__proto__</div><div class="line">null</div><div class="line">&gt; Object.__proto__</div><div class="line">[Function]</div><div class="line">&gt; Object.__proto__.__proto__</div><div class="line">&#123;&#125;</div><div class="line">&gt; Object.__proto__.__proto__.__proto__</div><div class="line">null</div><div class="line">&gt; Function.prototype</div><div class="line">[Function]</div><div class="line">&gt; Object.prototype</div><div class="line">&#123;&#125;</div></pre></td></tr></table></figure>
<h3 id="使用-prototype-来进行面向对象编程"><a href="#使用-prototype-来进行面向对象编程" class="headerlink" title="使用 prototype 来进行面向对象编程"></a>使用 prototype 来进行面向对象编程</h3><p>在 ES6 之前，并没有 class 的对象，但即使到了 ES6，所谓的 class 不过是 syntax sugar，本质其实还是 prototype 编程。<br>面向对象的三大特点：封装、继承、多态，下面依次阐述。</p>
<h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>这个现在即使在 ES6 也没有很好地解决办法，目前所知道的方法有两种</p>
<ol>
<li>ES7 中出现以 # 表示私有属性</li>
<li>此外使用 ES6 的 Symbol 也可以达到模拟私有属性的效果</li>
</ol>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>这个在 ES6 之前的版本，其实是有方法进行继承模拟的，可以看下面的一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SupCls</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.x = <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line">SupCls.prototype.y = <span class="number">2</span>;</div><div class="line"><span class="keyword">var</span> supCls = <span class="keyword">new</span> SupCls();</div><div class="line"><span class="built_in">console</span>.log(supCls.x, supCls.y);</div><div class="line"><span class="comment">// output: 1, 2</span></div><div class="line"></div><div class="line"><span class="comment">// now we will make an inheritance</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubCls</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.z = <span class="number">3</span>;</div><div class="line">&#125;</div><div class="line">SubCls.prototype = <span class="keyword">new</span> SupCls();</div><div class="line">SubCls.prototype.constructor = SubCls;</div><div class="line"><span class="keyword">var</span> subCls = <span class="keyword">new</span> SubCls();</div><div class="line"><span class="built_in">console</span>.log(subCls.x, subCls.y, subCls.z);</div><div class="line"><span class="comment">// output: 1, 2, 3</span></div><div class="line"><span class="built_in">console</span>.log(subCls.__proto__);</div><div class="line"><span class="comment">// output: SubCls &#123; x: 1, constructor: [Function: SubCls] &#125;</span></div><div class="line"><span class="built_in">console</span>.log(subCls.hasOwnProperty(<span class="string">'x'</span>));</div><div class="line"><span class="comment">// output: false</span></div></pre></td></tr></table></figure>
<p>这里解释一下最关键的一步，<code>SubCls.prototype =  new SupCls()</code>，这可以使得新创建的 subCls 的 __proto__ 是 SupCls 的 prototype，从而使得其具有父类的属性。</p>
<p>除此之外还有一个令人迷惑的地方就是，为什么需要做 <code>SubCls.prototype.constructor = SubCls</code>？其实这步对于结果来说无关紧要，只是将 SubCls 的原型中的 constructor 指向正确的地方，如果没有这一步，上面的结果依然如此，也就是说 new 不会根据 prototype 的 constructor 来改变其行为，constructor 的存在只是给生成的 object 添加一个正确的引用。</p>
<p>其实这里有一个陷阱，那就是最后一条语句表明，x 不是 subCls 的instance属性！为什么会这样其实很好理解，因为 x 根据我们的做法是属于 SubCls 的 prototype 的属性，自然也是属于 subCls 的 __proto__ 属性。</p>
<p>那么如何解决这个问题呢？<br>其实很简单，无非就是把 SupCls 中的 this 换成我们想要的，也就是 SubCls 中的 this，做一次 binding 就行了。</p>
<p>看下面的实现方式:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SupCls</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.x = <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line">SupCls.prototype.y = <span class="number">2</span>;</div><div class="line"><span class="keyword">var</span> supCls = <span class="keyword">new</span> SupCls();</div><div class="line"><span class="built_in">console</span>.log(supCls.x, supCls.y);</div><div class="line"><span class="comment">// output: 1, 2</span></div><div class="line"></div><div class="line"><span class="comment">// now we will make an inheritance</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubCls</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.z = <span class="number">3</span>;</div><div class="line">    <span class="comment">// binding is done here</span></div><div class="line">    SubCls.supertype.constructor.apply(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line">SubCls.prototype = <span class="keyword">new</span> SupCls();</div><div class="line">SubCls.prototype.constructor = SubCls;</div><div class="line">SubCls.supertype = SupCls.prototype;</div><div class="line"><span class="keyword">var</span> subCls = <span class="keyword">new</span> SubCls();</div><div class="line"><span class="built_in">console</span>.log(subCls.x, subCls.y, subCls.z);</div><div class="line"><span class="comment">// output: 1, 2, 3</span></div><div class="line"><span class="built_in">console</span>.log(subCls.__proto__);</div><div class="line"><span class="comment">// output: SubCls &#123; x: 1, constructor: [Function: SubCls] &#125;</span></div><div class="line"><span class="built_in">console</span>.log(subCls.hasOwnProperty(<span class="string">'x'</span>));</div><div class="line"><span class="comment">// output: true</span></div></pre></td></tr></table></figure>
<p>也许你以为到这里就解决问题了，但实际上还有一个问题！<br>你可以发现，SupCls 这个 function 被调用了两次，这个意味着什么？但是这个是可以避免的，为什么这么说？我们看这两次的调用时机：</p>
<ol>
<li><code>SubCls.prototype = new SupCls();</code></li>
<li><code>SubCls.supertype.constructor.apply(this);</code></li>
</ol>
<p>明显可以发现第一次的调用其实没有必要，因此第一次的调用我们只是想要拿到 SupCls 的 prototype 信息，而不是以它为 constructor 创建的 instance 信息，所以为了避免这个，我们可以这样来结束讨论：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SupCls</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.x = <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line">SupCls.prototype.y = <span class="number">2</span>;</div><div class="line"><span class="keyword">var</span> supCls = <span class="keyword">new</span> SupCls();</div><div class="line"><span class="built_in">console</span>.log(supCls.x, supCls.y);</div><div class="line"><span class="comment">// output: 1, 2</span></div><div class="line"></div><div class="line"><span class="comment">// now we will make an inheritance</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubCls</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.z = <span class="number">3</span>;</div><div class="line">    <span class="comment">// binding is done here</span></div><div class="line">    SubCls.supertype.constructor.apply(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// new part start</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">middleConstructor</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">middleConstructor.prototype = SupCls.prototype;</div><div class="line">SubCls.prototype = <span class="keyword">new</span> middleConstructor();</div><div class="line"><span class="comment">// new part end</span></div><div class="line"></div><div class="line">SubCls.prototype.constructor = SubCls;</div><div class="line">SubCls.supertype = SupCls.prototype;</div><div class="line"><span class="keyword">var</span> subCls = <span class="keyword">new</span> SubCls();</div><div class="line"><span class="built_in">console</span>.log(subCls.x, subCls.y, subCls.z);</div><div class="line"><span class="comment">// output: 1, 2, 3</span></div><div class="line"><span class="built_in">console</span>.log(subCls.__proto__);</div><div class="line"><span class="comment">// output: SubCls &#123; x: 1, constructor: [Function: SubCls] &#125;</span></div><div class="line"><span class="built_in">console</span>.log(subCls.hasOwnProperty(<span class="string">'x'</span>));</div><div class="line"><span class="comment">// output: true</span></div></pre></td></tr></table></figure></p>
<p>也许有人会有这样的疑惑，为什么不直接将 SupCls 的 prototype 赋给 SubCls 的 prototype，对此，我表示你自己一试，想一下就知道了原因了。</p>
<p>根据 Dmitry Soshnikov 的说法，ES6 class 的继承就是通过这样的方法实现的，不过我认为应该还是有出入的，这个还需要仔细探究一下。</p>

        
      
    </div>

    

    
  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/02/14/Hexo_With_GitHub/">Deploy Hexo Blogs on GitHub Pages</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Feb 14, 2017
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h3 id="Create-a-GitHub-Page"><a href="#Create-a-GitHub-Page" class="headerlink" title="Create a GitHub Page"></a>Create a GitHub Page</h3><p>Follow the steps on this <a href="https://pages.github.com/" target="_blank" rel="external">page</a> to create a personal website, say <code>https://username.github.io</code>.</p>
<h3 id="Install-Hexo"><a href="#Install-Hexo" class="headerlink" title="Install Hexo"></a>Install Hexo</h3><p>After <code>git</code> and <code>nodejs</code> installed, get the Hexo installed by:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g hexo-cli</div></pre></td></tr></table></figure></p>
<p>Try to get what you are confused about from this <a href="https://hexo.io/docs/" target="_blank" rel="external">page</a>.</p>
<h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-https-username-github-io"><a href="#Deploy-to-https-username-github-io" class="headerlink" title="Deploy to https://username.github.io"></a>Deploy to <code>https://username.github.io</code></h3><p>Before the deploying, change the deploy settings:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># Deployment</div><div class="line">## Docs: https://hexo.io/docs/deployment.html</div><div class="line">deploy:</div><div class="line">  type: git</div><div class="line">  repository: git@github.com:username/username.github.io.git</div><div class="line">  branch: master</div></pre></td></tr></table></figure></p>
<p>After the setting, the git deploy helper should be installed by:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-deployer-git --save</div></pre></td></tr></table></figure></p>
<p>Deploying:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure></p>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

        
      
    </div>

    

    
  </article>

    
  </section>

  
  <nav class="pagination">
    
    
  </nav>


          </div>
          
        </div>  
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:xykwei@gmail.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
        
          <a href="https://github.com/ShiKaiWi" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
    
    
  </div>


<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a>
  </span>
  
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
    
    2017

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">ShiKaiWi</span>
  </span>
</div>
      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    


    
  





  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  

    <script type="text/javascript" src="/js/src/even.js?v=2.2.x"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.2.x"></script>

  </body>
</html>